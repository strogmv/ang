// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: postgres_repo.tmpl
// Repository: UserRepository
// Entity: User
// Table: users
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: 0.1.94
// InputHash: 4fa1317f67183096ec3725c403afcea8cb7683b885101240f821ee8f6cfef998
// CompilerHash: 69ae3e663ffdf36c126d325756d4cdc925427a9b8e8e770481a1d50dfec04044
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package postgres

// ============================================================================
// SECTION: Imports
// PURPOSE: Database driver and domain entity imports
// ============================================================================
import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/strogmv/ang/internal/domain"
)

// ============================================================================
// SECTION: Repository Struct
// PURPOSE: UserRepository provides data access for User entity
// PATTERN: Repository Pattern - abstracts data persistence from business logic
// TABLE: users
// INTERFACE: Implements port.UserRepository
// ============================================================================
type UserRepository struct {
	DB *pgxpool.Pool
}

// ============================================================================
// SECTION: Constructor
// PURPOSE: Create repository with database pool connection
// USAGE: Called from main.go during application bootstrap
// ============================================================================
func NewUserRepository(db *pgxpool.Pool) *UserRepository {
	return &UserRepository{DB: db}
}

// ============================================================================
// METHOD: Save
// PURPOSE: Persist entity to database (INSERT or UPDATE via upsert)
// PATTERN: Upsert - uses ON CONFLICT DO UPDATE for idempotent writes
// SQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
// ============================================================================
func (r *UserRepository) Save(ctx context.Context, entity *domain.User) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if err := entity.Validate(); err != nil {
		return fmt.Errorf("invalid entity: %w", err)
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `
		INSERT INTO users (id, email, passwordhash, name, role, avatarurl, createdat, updatedat)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
		ON CONFLICT (id) DO UPDATE
		SET email = EXCLUDED.email, passwordhash = EXCLUDED.passwordhash, name = EXCLUDED.name, role = EXCLUDED.role, avatarurl = EXCLUDED.avatarurl, createdat = EXCLUDED.createdat, updatedat = EXCLUDED.updatedat
	`, entity.ID, entity.Email, entity.PasswordHash, entity.Name, entity.Role, entity.AvatarURL, entity.CreatedAt, entity.UpdatedAt)
	return err
}

// ============================================================================
// METHOD: FindByID
// PURPOSE: Retrieve single entity by primary key
// RETURNS: *entity or nil if not found (nil, nil means not found)
// SQL: SELECT ... FROM users WHERE id = $1
// ============================================================================
func (r *UserRepository) FindByID(ctx context.Context, id string) (*domain.User, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, email, passwordhash, name, role, avatarurl, createdat::text, updatedat::text
		FROM users
		WHERE id = $1
		LIMIT 1
	`, id)
	var entity domain.User
	var idVal string
	var emailVal string
	var passwordhashVal string
	var nameVal string
	var roleVal string
	var avatarurlVal string
	var createdatVal time.Time
	var updatedatVal time.Time
	if err := row.Scan(
		&idVal,
		&emailVal,
		&passwordhashVal,
		&nameVal,
		&roleVal,
		&avatarurlVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByID scan: %w", err)
	}
	entity.ID = idVal
	entity.Email = emailVal
	entity.PasswordHash = passwordhashVal
	entity.Name = nameVal
	entity.Role = roleVal
	entity.AvatarURL = avatarurlVal
	entity.CreatedAt = createdatVal
	entity.UpdatedAt = updatedatVal
	return &entity, nil
}

// ============================================================================
// METHOD: Delete
// PURPOSE: Remove entity from database by primary key
// SQL: DELETE FROM users WHERE id = $1
// ============================================================================
func (r *UserRepository) Delete(ctx context.Context, id string) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `DELETE FROM users WHERE id = $1`, id)
	return err
}

// ============================================================================
// METHOD: ListAll
// PURPOSE: Retrieve paginated list of all entities
// SQL: SELECT ... FROM users ORDER BY id LIMIT $1 OFFSET $2
// ============================================================================
func (r *UserRepository) ListAll(ctx context.Context, offset, limit int) ([]domain.User, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, email, passwordhash, name, role, avatarurl, createdat::text, updatedat::text
		FROM users
		ORDER BY id
		LIMIT $1 OFFSET $2
	`, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("ListAll query: %w", err)
	}
	defer rows.Close()
	var items []domain.User
	for rows.Next() {
		var entity domain.User
		var idVal string
		var emailVal string
		var passwordhashVal string
		var nameVal string
		var roleVal string
		var avatarurlVal string
		var createdatVal time.Time
		var updatedatVal time.Time
		if err := rows.Scan(
			&idVal,
			&emailVal,
			&passwordhashVal,
			&nameVal,
			&roleVal,
			&avatarurlVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, fmt.Errorf("ListAll scan: %w", err)
		}
		entity.ID = idVal
		entity.Email = emailVal
		entity.PasswordHash = passwordhashVal
		entity.Name = nameVal
		entity.Role = roleVal
		entity.AvatarURL = avatarurlVal
		entity.CreatedAt = createdatVal
		entity.UpdatedAt = updatedatVal
		items = append(items, entity)
	}
	return items, nil
}

// ============================================================================
// SECTION: Custom Finder Methods
// PURPOSE: Query methods defined in CUE repository configuration
// PATTERN: Each finder generates SELECT with specific WHERE/ORDER BY clauses
// ============================================================================
// FINDER: FindByEmail
// PARAMS: email string
// RETURNS: *domain.User
func (r *UserRepository) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, email, passwordhash, name, role, avatarurl, createdat::text, updatedat::text
		FROM users
		WHERE email = $1
		LIMIT 1
	`, email)
	var entity domain.User
	var idVal string
	var emailVal string
	var passwordhashVal string
	var nameVal string
	var roleVal string
	var avatarurlVal string
	var createdatVal time.Time
	var updatedatVal time.Time
	if err := row.Scan(
		&idVal,
		&emailVal,
		&passwordhashVal,
		&nameVal,
		&roleVal,
		&avatarurlVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByEmail scan: %w", err)
	}
	entity.ID = idVal
	entity.Email = emailVal
	entity.PasswordHash = passwordhashVal
	entity.Name = nameVal
	entity.Role = roleVal
	entity.AvatarURL = avatarurlVal
	entity.CreatedAt = createdatVal
	entity.UpdatedAt = updatedatVal
	return &entity, nil
}

// Ensure optional field scanners are referenced.
var _ = sql.NullString{}
