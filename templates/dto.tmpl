// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: {{ ANGVersion }}
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================

package dto

import (
	"{{ GoModule }}/internal/domain"
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// {{ ExportName .Name }}DTO represents the data transfer object.
type {{ ExportName .Name }}DTO struct {
{{- range .Fields }}
	{{ ExportName .Name }} {{ DTOType .Type }} `json:"{{ JSONName .Name }}"`
{{- end }}
}

// ToDomain converts DTO to domain entity.
func (d *{{ ExportName .Name }}DTO) ToDomain() *domain.{{ ExportName .Name }} {
	if d == nil {
		return nil
	}
	return &domain.{{ ExportName .Name }}{
{{- range .Fields }}
{{- if IsEntity .Type }}
		{{ ExportName .Name }}: func() domain.{{ EntityName .Type }} {
			if v := d.{{ ExportName .Name }}.ToDomain(); v != nil {
				return *v
			}
			return domain.{{ EntityName .Type }}{}
		}(),
{{- else if IsListEntity .Type }}
		{{ ExportName .Name }}: func(items []{{ DTOElemType .Type }}) []domain.{{ EntityName .Type }} {
			if len(items) == 0 {
				return nil
			}
			out := make([]domain.{{ EntityName .Type }}, 0, len(items))
			for _, it := range items {
				if v := it.ToDomain(); v != nil {
					out = append(out, *v)
				}
			}
			return out
		}(d.{{ ExportName .Name }}),
{{- else }}
		{{ ExportName .Name }}: d.{{ ExportName .Name }},
{{- end }}
{{- end }}
	}
}

// FromDomain converts domain entity to DTO.
func (d *{{ ExportName .Name }}DTO) FromDomain(e *domain.{{ ExportName .Name }}) {
	if e == nil {
		return
	}
{{- range .Fields }}
{{- if IsEntity .Type }}
	{{- $conv := DTOConverter .Type }}
	{{- if ne (EntityName .Type) "" }}{{ $conv = EntityName .Type }}{{ end }}
	if v := To{{ $conv }}DTO(&e.{{ ExportName .Name }}); v != nil {
		d.{{ ExportName .Name }} = *v
	}
{{- else if IsListEntity .Type }}
	if len(e.{{ ExportName .Name }}) > 0 {
		d.{{ ExportName .Name }} = make([]{{ DTOElemType .Type }}, 0, len(e.{{ ExportName .Name }}))
		for _, it := range e.{{ ExportName .Name }} {
			{{- $conv := DTOListConverter .Type }}
			{{- if ne (EntityName .Type) "" }}{{ $conv = EntityName .Type }}{{ end }}
			if v := To{{ $conv }}DTO(&it); v != nil {
				d.{{ ExportName .Name }} = append(d.{{ ExportName .Name }}, *v)
			}
		}
	}
{{- else }}
	d.{{ ExportName .Name }} = e.{{ ExportName .Name }}
{{- end }}
{{- end }}
}

// ToDTO helper for quick conversion.
func To{{ ExportName .Name }}DTO(e *domain.{{ ExportName .Name }}) *{{ ExportName .Name }}DTO {
	if e == nil {
		return nil
	}
	d := &{{ ExportName .Name }}DTO{}
	d.FromDomain(e)
	return d
}

func (d *{{ ExportName .Name }}DTO) Validate() error {
{{- if HasImport .Imports "fmt" }}
	_ = fmt.Errorf
{{- end }}
{{- range .Fields }}
{{- if .Constraints }}
	{{- if .Constraints.Min }}
	if d.{{ ExportName .Name }} < {{ .Constraints.Min }} {
		return fmt.Errorf("field {{ JSONName .Name }} must be >= %v", {{ .Constraints.Min }})
	}
	{{- end }}
	{{- if .Constraints.Max }}
	if d.{{ ExportName .Name }} > {{ .Constraints.Max }} {
		return fmt.Errorf("field {{ JSONName .Name }} must be <= %v", {{ .Constraints.Max }})
	}
	{{- end }}
	{{- if .Constraints.MinLen }}
	if len(d.{{ ExportName .Name }}) < {{ .Constraints.MinLen }} {
		return fmt.Errorf("field {{ JSONName .Name }} length must be >= %v", {{ .Constraints.MinLen }})
	}
	{{- end }}
	{{- if .Constraints.MaxLen }}
	if len(d.{{ ExportName .Name }}) > {{ .Constraints.MaxLen }} {
		return fmt.Errorf("field {{ JSONName .Name }} length must be <= %v", {{ .Constraints.MaxLen }})
	}
	{{- end }}
{{- end }}
{{- end }}
	return nil
}
