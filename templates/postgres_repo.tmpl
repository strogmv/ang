// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: postgres_repo.tmpl
// Repository: {{ ExportName .Name }}
// Entity: {{ ExportName .Entity }}
// Table: {{ .Table }}
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: {{ ANGVersion }}
// InputHash: {{ InputHash }}
// CompilerHash: {{ CompilerHash }}
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package postgres

// ============================================================================
// SECTION: Imports
// PURPOSE: Database driver and domain entity imports
// ============================================================================
import (
	"context"
	"database/sql"
	"fmt"
	{{- if .HasTime }}
	"time"
	{{- end }}

	"github.com/jackc/pgx/v5/pgxpool"
	"{{GoModule}}/internal/domain"
)

// ============================================================================
// SECTION: Repository Struct
// PURPOSE: {{ ExportName .Name }} provides data access for {{ ExportName .Entity }} entity
// PATTERN: Repository Pattern - abstracts data persistence from business logic
// TABLE: {{ .Table }}
// INTERFACE: Implements port.{{ ExportName .Entity }}Repository
// ============================================================================
type {{ ExportName .Name }} struct {
	DB *pgxpool.Pool
}

// ============================================================================
// SECTION: Constructor
// PURPOSE: Create repository with database pool connection
// USAGE: Called from main.go during application bootstrap
// ============================================================================
func New{{ ExportName .Name }}(db *pgxpool.Pool) *{{ ExportName .Name }} {
	return &{{ ExportName .Name }}{DB: db}
}

// ============================================================================
// METHOD: Save
// PURPOSE: Persist entity to database (INSERT or UPDATE via upsert)
// PATTERN: Upsert - uses ON CONFLICT DO UPDATE for idempotent writes
// SQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
// ============================================================================
func (r *{{ ExportName .Name }}) Save(ctx context.Context, entity *domain.{{ ExportName .Entity }}) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if err := entity.Validate(); err != nil {
		return fmt.Errorf("invalid entity: %w", err)
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `
		INSERT INTO {{ .Table }} ({{ .Columns }})
		VALUES ({{ .Placeholders }})
		ON CONFLICT (id) DO UPDATE
		SET {{ .UpdateSet }}
	`, {{ .InsertArgs }})
	return err
}

// ============================================================================
// METHOD: FindByID
// PURPOSE: Retrieve single entity by primary key
// RETURNS: *entity or nil if not found (nil, nil means not found)
// SQL: SELECT ... FROM {{ .Table }} WHERE id = $1
// ============================================================================
func (r *{{ ExportName .Name }}) FindByID(ctx context.Context, id string) (*domain.{{ ExportName .Entity }}, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT {{ .FindByIDPlan.ColList }}
		FROM {{ .Table }}
		WHERE id = $1
		LIMIT 1
	`, id)
	var entity domain.{{ ExportName .Entity }}
	{{- range .FindByIDPlan.Variables }}
	var {{ .TmpVar }} {{ .TmpType }}
	{{- end }}
	if err := row.Scan(
		{{- range .FindByIDPlan.Variables }}
		&{{ .TmpVar }},
		{{- end }}
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByID scan: %w", err)
	}
	{{- range .FindByIDPlan.Variables }}
	{{- if .Guard }}
	if {{ .Guard }} {
		{{ .AssignCode }}
	}
	{{- else }}
	{{ .AssignCode }}
	{{- end }}
	{{- end }}
	return &entity, nil
}

// ============================================================================
// METHOD: Delete
// PURPOSE: Remove entity from database by primary key
// SQL: DELETE FROM {{ .Table }} WHERE id = $1
// ============================================================================
func (r *{{ ExportName .Name }}) Delete(ctx context.Context, id string) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `DELETE FROM {{ .Table }} WHERE id = $1`, id)
	return err
}

{{- $hasListAll := false }}
{{- range .Finders }}{{ if eq .Name "ListAll" }}{{ $hasListAll = true }}{{ end }}{{ end }}
{{- if not $hasListAll }}
// ============================================================================
// METHOD: ListAll
// PURPOSE: Retrieve paginated list of all entities
// SQL: SELECT ... FROM {{ .Table }} ORDER BY id LIMIT $1 OFFSET $2
// ============================================================================
func (r *{{ ExportName .Name }}) ListAll(ctx context.Context, offset, limit int) ([]domain.{{ ExportName .Entity }}, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT {{ .ListAllPlan.ColList }}
		FROM {{ .Table }}
		ORDER BY id
		LIMIT $1 OFFSET $2
	`, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("ListAll query: %w", err)
	}
	defer rows.Close()
	var items []domain.{{ ExportName .Entity }}
	for rows.Next() {
		var entity domain.{{ ExportName .Entity }}
		{{- range .ListAllPlan.Variables }}
		var {{ .TmpVar }} {{ .TmpType }}
		{{- end }}
		if err := rows.Scan(
			{{- range .ListAllPlan.Variables }}
			&{{ .TmpVar }},
			{{- end }}
		); err != nil {
			return nil, fmt.Errorf("ListAll scan: %w", err)
		}
		{{- range .ListAllPlan.Variables }}
		{{- if .Guard }}
		if {{ .Guard }} {
			{{ .AssignCode }}
		}
		{{- else }}
		{{ .AssignCode }}
		{{- end }}
		{{- end }}
		items = append(items, entity)
	}
	return items, nil
}
{{- end }}

// ============================================================================
// SECTION: Custom Finder Methods
// PURPOSE: Query methods defined in CUE repository configuration
// PATTERN: Each finder generates SELECT with specific WHERE/ORDER BY clauses
// ============================================================================

{{- range .Finders }}
// FINDER: {{ .Name }}
// PARAMS: {{ if .ParamsSig }}{{ .ParamsSig }}{{ else }}none{{ end }}
// RETURNS: {{ .ReturnType }}
func (r *{{ ExportName $.Name }}) {{ .Name }}(ctx context.Context{{ if .ParamsSig }}, {{ .ParamsSig }}{{ end }}) ({{ .ReturnType }}, error) {
	if r.DB == nil {
		return {{ .ReturnZero }}, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	{{- if .CustomSQL }}
	{{- if .ReturnSlice }}
	rows, err := exec.Query(ctx, `{{ .CustomSQL }}`{{ if .Args }}, {{ .Args }}{{ end }})
	if err != nil {
		return {{ .ReturnZero }}, err
	}
	defer rows.Close()
	var items {{ .ReturnType }}
	for rows.Next() {
		{{- if or .SelectEntity .SelectCustomEntity }}
		var entity {{- if .SelectCustomEntity }} domain.{{ ExportName .CustomEntityName }}{{- else }} domain.{{ ExportName $.Entity }}{{- end }}
		{{- range .ScanPlan.Variables }}
		var {{ .TmpVar }} {{ .TmpType }}
		{{- end }}
		if err := rows.Scan(
			{{- range .ScanPlan.Variables }}
			&{{ .TmpVar }},
			{{- end }}
		); err != nil {
			return {{ .ReturnZero }}, err
		}
		{{- range .ScanPlan.Variables }}
		{{- if .Guard }}
		if {{ .Guard }} {
			{{ .AssignCode }}
		}
		{{- else }}
		{{ .AssignCode }}
		{{- end }}
		{{- end }}
		items = append(items, entity)
			{{- else if .SelectFields }}
		var v {{ (index .SelectFields 0).Type }}
		if err := rows.Scan(&v); err != nil {
			return {{ .ReturnZero }}, err
		}
		items = append(items, v)
		{{- else }}
		return {{ .ReturnZero }}, fmt.Errorf("{{ .Name }}: no scan fields for custom sql list")
		{{- end }}
	}
	if err := rows.Err(); err != nil {
		return {{ .ReturnZero }}, err
	}
	return items, nil
	{{- else }}
	row := exec.QueryRow(ctx, `{{ .CustomSQL }}`{{ if .Args }}, {{ .Args }}{{ end }})
	{{- if or .SelectEntity .SelectCustomEntity }}
	var entity {{- if .SelectCustomEntity }} domain.{{ ExportName .CustomEntityName }}{{- else }} domain.{{ ExportName $.Entity }}{{- end }}
	{{- range .ScanPlan.Variables }}
	var {{ .TmpVar }} {{ .TmpType }}
	{{- end }}
	if err := row.Scan(
		{{- range .ScanPlan.Variables }}
		&{{ .TmpVar }},
		{{- end }}
	); err != nil {
		if err.Error() == "no rows in result set" {
			return {{ .ReturnZero }}, nil
		}
		return {{ .ReturnZero }}, fmt.Errorf("{{ .Name }} scan: %w", err)
	}
	{{- range .ScanPlan.Variables }}
	{{- if .Guard }}
	if {{ .Guard }} {
		{{ .AssignCode }}
	}
	{{- else }}
	{{ .AssignCode }}
	{{- end }}
	{{- end }}
	return &entity, nil
	{{- else if .SelectFields }}
	var v {{ (index .SelectFields 0).Type }}
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return {{ .ReturnZero }}, nil
		}
		return {{ .ReturnZero }}, err
	}
	return v, nil
	{{- else }}
	return {{ .ReturnZero }}, fmt.Errorf("{{ .Name }}: no scan fields defined")
	{{- end }}
	{{- end }}
	{{- else }}
	{{- if eq .Action "delete" }}
	res, err := exec.Exec(ctx, `DELETE FROM {{ $.Table }}{{ .WhereSQL }}`{{ .ArgsSuffix }})
	if err != nil {
		return {{ .ReturnZero }}, err
	}
	return res.RowsAffected(), nil
	{{- else if .ReturnSlice }}
	rows, err := exec.Query(ctx, `
		SELECT {{ .SelectCols }}
		FROM {{ $.Table }}
		{{- if .WhereClause }}
		WHERE {{ .WhereClause }}
		{{- end }}
		{{- if .OrderBySQL }}
		ORDER BY {{ .OrderBySQL }}
		{{- end }}
	`{{ if .Args }}, {{ .Args }}{{ end }})
	if err != nil {
		return {{ .ReturnZero }}, err
	}
	defer rows.Close()
	var items {{ .ReturnType }}
	for rows.Next() {
		{{- if or .SelectEntity .SelectCustomEntity }}
		var entity {{- if .SelectCustomEntity }} domain.{{ ExportName .CustomEntityName }}{{- else }} domain.{{ ExportName $.Entity }}{{- end }}
		{{- range .ScanPlan.Variables }}
		var {{ .TmpVar }} {{ .TmpType }}
		{{- end }}
		if err := rows.Scan(
			{{- range .ScanPlan.Variables }}
			&{{ .TmpVar }},
			{{- end }}
		); err != nil {
			return {{ .ReturnZero }}, err
		}
		{{- range .ScanPlan.Variables }}
		{{- if .Guard }}
		if {{ .Guard }} {
			{{ .AssignCode }}
		}
		{{- else }}
		{{ .AssignCode }}
		{{- end }}
		{{- end }}
		items = append(items, entity)
			{{- else if .SelectFields }}
		var v {{ (index .SelectFields 0).Type }}
		if err := rows.Scan(&v); err != nil {
			return {{ .ReturnZero }}, err
		}
		items = append(items, v)
		{{- else }}
		return {{ .ReturnZero }}, fmt.Errorf("{{ .Name }}: no scan fields for standard list")
		{{- end }}
	}
	if err := rows.Err(); err != nil {
		return {{ .ReturnZero }}, err
	}
	return items, nil
	{{- else }}
	row := exec.QueryRow(ctx, `
		SELECT {{ .SelectCols }}
		FROM {{ $.Table }}
		{{- if .WhereClause }}
		WHERE {{ .WhereClause }}
		{{- end }}
		{{- if .OrderBySQL }}
		ORDER BY {{ .OrderBySQL }}
		{{- end }}
		{{- if .ForUpdate }}
		FOR UPDATE
		{{- end }}
		LIMIT 1
	`{{ if .Args }}, {{ .Args }}{{ end }})
	{{- if or .SelectEntity .SelectCustomEntity }}
	var entity {{- if .SelectCustomEntity }} domain.{{ ExportName .CustomEntityName }}{{- else }} domain.{{ ExportName $.Entity }}{{- end }}
	{{- range .ScanPlan.Variables }}
	var {{ .TmpVar }} {{ .TmpType }}
	{{- end }}
	if err := row.Scan(
		{{- range .ScanPlan.Variables }}
		&{{ .TmpVar }},
		{{- end }}
	); err != nil {
		if err.Error() == "no rows in result set" {
			return {{ .ReturnZero }}, nil
		}
		return {{ .ReturnZero }}, fmt.Errorf("{{ .Name }} scan: %w", err)
	}
	{{- range .ScanPlan.Variables }}
	{{- if .Guard }}
	if {{ .Guard }} {
		{{ .AssignCode }}
	}
	{{- else }}
	{{ .AssignCode }}
	{{- end }}
	{{- end }}
	return &entity, nil
	{{- else if .SelectFields }}
	var v {{ (index .SelectFields 0).Type }}
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return {{ .ReturnZero }}, nil
		}
		return {{ .ReturnZero }}, err
	}
	return v, nil
	{{- else }}
	return {{ .ReturnZero }}, fmt.Errorf("{{ .Name }}: no scan fields for single row")
	{{- end }}
	{{- end }}
	{{- end }}
}
{{- end }}

// Ensure optional field scanners are referenced.
var _ = sql.NullString{}
