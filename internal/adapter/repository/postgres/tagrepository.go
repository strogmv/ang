// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: postgres_repo.tmpl
// Repository: TagRepository
// Entity: Tag
// Table: tags
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: 0.1.51
// InputHash: 027eaf3d0fffed4e5d3dbe6c68942a856acd710227485d4e2e76bb27357fa14a
// CompilerHash: 08a642c084b87d9392c0c2534fdbe0ff4b08989904e030ab4a5d545a605fc59c
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package postgres

// ============================================================================
// SECTION: Imports
// PURPOSE: Database driver and domain entity imports
// ============================================================================
import (
	"context"
	"database/sql"
	"fmt"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/strogmv/ang/internal/domain"
)

// ============================================================================
// SECTION: Repository Struct
// PURPOSE: TagRepository provides data access for Tag entity
// PATTERN: Repository Pattern - abstracts data persistence from business logic
// TABLE: tags
// INTERFACE: Implements port.TagRepository
// ============================================================================
type TagRepository struct {
	DB *pgxpool.Pool
}

// ============================================================================
// SECTION: Constructor
// PURPOSE: Create repository with database pool connection
// USAGE: Called from main.go during application bootstrap
// ============================================================================
func NewTagRepository(db *pgxpool.Pool) *TagRepository {
	return &TagRepository{DB: db}
}

// ============================================================================
// METHOD: Save
// PURPOSE: Persist entity to database (INSERT or UPDATE via upsert)
// PATTERN: Upsert - uses ON CONFLICT DO UPDATE for idempotent writes
// SQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
// ============================================================================
func (r *TagRepository) Save(ctx context.Context, entity *domain.Tag) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if err := entity.Validate(); err != nil {
		return fmt.Errorf("invalid entity: %w", err)
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `
		INSERT INTO tags (id, name, slug, description)
		VALUES ($1, $2, $3, $4)
		ON CONFLICT (id) DO UPDATE
		SET name = EXCLUDED.name, slug = EXCLUDED.slug, description = EXCLUDED.description
	`, entity.ID, entity.Name, entity.Slug, entity.Description)
	return err
}

// ============================================================================
// METHOD: FindByID
// PURPOSE: Retrieve single entity by primary key
// RETURNS: *entity or nil if not found (nil, nil means not found)
// SQL: SELECT ... FROM tags WHERE id = $1
// ============================================================================
func (r *TagRepository) FindByID(ctx context.Context, id string) (*domain.Tag, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, name, slug, description
		FROM tags
		WHERE id = $1
		LIMIT 1
	`, id)
	var entity domain.Tag
	var idVal sql.NullString
	var nameVal sql.NullString
	var slugVal sql.NullString
	var descriptionVal sql.NullString
	if err := row.Scan(
		&idVal,
		&nameVal,
		&slugVal,
		&descriptionVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByID scan: %w", err)
	}
	if idVal.Valid {
		unmarshalJSON(idVal.String, &entity.ID)
	}
	if nameVal.Valid {
		unmarshalJSON(nameVal.String, &entity.Name)
	}
	if slugVal.Valid {
		unmarshalJSON(slugVal.String, &entity.Slug)
	}
	if descriptionVal.Valid {
		unmarshalJSON(descriptionVal.String, &entity.Description)
	}
	return &entity, nil
}

// ============================================================================
// METHOD: Delete
// PURPOSE: Remove entity from database by primary key
// SQL: DELETE FROM tags WHERE id = $1
// ============================================================================
func (r *TagRepository) Delete(ctx context.Context, id string) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `DELETE FROM tags WHERE id = $1`, id)
	return err
}

// ============================================================================
// SECTION: Custom Finder Methods
// PURPOSE: Query methods defined in CUE repository configuration
// PATTERN: Each finder generates SELECT with specific WHERE/ORDER BY clauses
// ============================================================================
// FINDER: FindBySlug
// PARAMS: slug map[string]any
// RETURNS: *domain.Tag
func (r *TagRepository) FindBySlug(ctx context.Context, slug map[string]any) (*domain.Tag, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, name, slug, description
		FROM tags
		WHERE slug = $1
		LIMIT 1
	`, slug)
	var entity domain.Tag
	var idVal sql.NullString
	var nameVal sql.NullString
	var slugVal sql.NullString
	var descriptionVal sql.NullString
	if err := row.Scan(
		&idVal,
		&nameVal,
		&slugVal,
		&descriptionVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindBySlug scan: %w", err)
	}
	if idVal.Valid {
		unmarshalJSON(idVal.String, &entity.ID)
	}
	if nameVal.Valid {
		unmarshalJSON(nameVal.String, &entity.Name)
	}
	if slugVal.Valid {
		unmarshalJSON(slugVal.String, &entity.Slug)
	}
	if descriptionVal.Valid {
		unmarshalJSON(descriptionVal.String, &entity.Description)
	}
	return &entity, nil
}

// FINDER: ListAll
// PARAMS: none
// RETURNS: []domain.Tag
func (r *TagRepository) ListAll(ctx context.Context) ([]domain.Tag, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, name, slug, description
		FROM tags
		ORDER BY name ASC
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Tag
	for rows.Next() {
		var entity domain.Tag
		var idVal sql.NullString
		var nameVal sql.NullString
		var slugVal sql.NullString
		var descriptionVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&nameVal,
			&slugVal,
			&descriptionVal,
		); err != nil {
			return nil, err
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if nameVal.Valid {
			unmarshalJSON(nameVal.String, &entity.Name)
		}
		if slugVal.Valid {
			unmarshalJSON(slugVal.String, &entity.Slug)
		}
		if descriptionVal.Valid {
			unmarshalJSON(descriptionVal.String, &entity.Description)
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: ListByPost
// PARAMS: id map[string]any
// RETURNS: []domain.Tag
func (r *TagRepository) ListByPost(ctx context.Context, id map[string]any) ([]domain.Tag, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, name, slug, description
		FROM tags
		WHERE id IN $1
	`, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Tag
	for rows.Next() {
		var entity domain.Tag
		var idVal sql.NullString
		var nameVal sql.NullString
		var slugVal sql.NullString
		var descriptionVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&nameVal,
			&slugVal,
			&descriptionVal,
		); err != nil {
			return nil, err
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if nameVal.Valid {
			unmarshalJSON(nameVal.String, &entity.Name)
		}
		if slugVal.Valid {
			unmarshalJSON(slugVal.String, &entity.Slug)
		}
		if descriptionVal.Valid {
			unmarshalJSON(descriptionVal.String, &entity.Description)
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Ensure optional field scanners are referenced.
var _ = sql.NullString{}
