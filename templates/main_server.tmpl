// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: main_server.tmpl
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================

{{- /* ======================================================================
   TEMPLATE ASSERTIONS - Validate input data before generation
   These will fail the build if the data is invalid
   ====================================================================== */ -}}
{{- if eq (len .Services) 0 }}{{ fail "No services defined - check cue/api/*.cue" }}{{ end }}

// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: {{ ANGVersion }}
// InputHash: {{ InputHash }}
// CompilerHash: {{ CompilerHash }}
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package main

// ============================================================================
// SECTION: Imports
// PURPOSE: Import all required packages based on enabled features
// CONDITIONAL IMPORTS:
//   - pgxpool: when HasSQL is true (PostgreSQL database)
//   - mongo: when HasMongo is true (MongoDB)
//   - redis: when HasCache or auth uses redis/hybrid
//   - nats: when HasNats is true (event bus)
//   - s3: when HasS3 is true (file storage)
//   - mailer: when email notifications enabled
// ============================================================================
import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"
	{{ if .HasNats }}"encoding/json"{{ end }}

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	{{ if .HasSQL }}"github.com/jackc/pgx/v5/pgxpool"{{ end }}
	{{ if .HasMongo }}
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	{{ end }}

	{{ if or .HasCache (or (eq .AuthRefreshStore "redis") (eq .AuthRefreshStore "hybrid")) }}"{{.GoModule}}/internal/adapter/cache/redis"{{ end }}
	{{ if HasRepoEntities .Services }}"{{.GoModule}}/internal/adapter/repository/postgres"{{ end }}
	{{ if HasMongoRepoEntities .Entities }}mongorepo "{{.GoModule}}/internal/adapter/repository/mongo"{{ end }}
	{{ if .HasNats }}
	"{{.GoModule}}/internal/adapter/events/nats"
	"{{.GoModule}}/internal/domain"
	{{ end }}
	{{ if .HasS3 }}
	"{{.GoModule}}/internal/adapter/storage/s3"
	{{ end }}
	"{{.GoModule}}/internal/config"
	"{{.GoModule}}/internal/pkg/logger"
	"{{.GoModule}}/internal/pkg/tracing"
	{{ if .HasScheduler }}
	"{{.GoModule}}/internal/scheduler"
	{{ end }}
	"{{.GoModule}}/internal/port"
	"{{.GoModule}}/internal/service"
	transport "{{.GoModule}}/internal/transport/http"
	{{- if and .AuthService (eq .AuthRefreshStore "memory") }}
	authstore "{{.GoModule}}/internal/adapter/auth/memory"
	{{- end }}
	{{- if and .AuthService (or (eq .AuthRefreshStore "redis") (eq .AuthRefreshStore "hybrid")) }}
	authredis "{{.GoModule}}/internal/adapter/auth/redis"
	{{- end }}
	{{- if and .AuthService (or (eq .AuthRefreshStore "postgres") (eq .AuthRefreshStore "hybrid")) }}
	authpg "{{.GoModule}}/internal/adapter/auth/postgres"
	{{- end }}
	{{- if and .AuthService (eq .AuthRefreshStore "hybrid") }}
	authhybrid "{{.GoModule}}/internal/adapter/auth/hybrid"
	{{- end }}
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

func main() {
	// ========================================================================
	// SECTION: Application Bootstrap
	// PURPOSE: Initialize logger, load configuration, setup tracing
	// FLOW: logger -> config -> tracing -> infrastructure
	// ========================================================================
	log := logger.Init()
	log.Info("Starting application...")
	ctx := context.Background()

	cfg, err := config.Load()
	if err != nil {
		log.Error("Failed to load config", "error", err)
		os.Exit(1)
	}
	if err := transport.SetAuthConfigFromConfig(cfg); err != nil {
		log.Error("Failed to init auth", "error", err)
		os.Exit(1)
	}

	tp, err := tracing.Init("ang-service")
	if err != nil {
		log.Error("Failed to init tracing", "error", err)
	} else {
		log.Info("Tracing initialized")
		defer func() {
			if err := tp.Shutdown(ctx); err != nil {
				log.Error("Tracing shutdown failed", "error", err)
			}
		}()
	}

	// ========================================================================
	// SECTION: Infrastructure Connections
	// PURPOSE: Establish connections to external services (DB, cache, message bus, storage)
	// PROVIDES: pgPool, redisClient, natsClient, s3Client, mailer
	// NOTE: Each connection is optional based on CUE architecture definition
	// ========================================================================

	{{ if .HasSQL }}
	// --- PostgreSQL Database Connection ---
	// ROLE: Primary data store for all domain entities
	// USED BY: All repository implementations (postgres/*.go)
	pgPool, err := pgxpool.New(ctx, cfg.DatabaseURL)
	if err != nil {
		log.Error("Postgres init failed", "error", err)
	} else {
		log.Info("Postgres connected")
		defer pgPool.Close()
	}
	{{ end }}

	{{ if .HasMongo }}
	// --- MongoDB Connection ---
	// ROLE: Document store (if enabled)
	mongoClient, err := mongo.Connect(ctx, options.Client().ApplyURI(cfg.MongoURL))
	if err != nil {
		log.Error("Mongo init failed", "error", err)
	} else {
		log.Info("Mongo connected")
		defer func() {
			if err := mongoClient.Disconnect(ctx); err != nil {
				log.Error("Mongo disconnect failed", "error", err)
			}
		}()
	}
	{{ end }}

	{{ if or .HasCache (or (eq .AuthRefreshStore "redis") (eq .AuthRefreshStore "hybrid")) }}
	// --- Redis Cache Connection ---
	// ROLE: Caching layer and/or auth token storage
	// USED BY: Rate limiting, session cache, refresh token store
	redisClient := redis.NewClient(cfg.RedisAddr)
	log.Info("Redis initialized", "addr", cfg.RedisAddr)
	transport.SetRedisClient(redisClient)
	_ = redisClient
	{{ end }}

	{{ if .HasNats }}
	// --- NATS Message Bus Connection ---
	// ROLE: Event-driven communication between services
	// USED BY: Event publishers (services), event subscribers (handlers, websocket broadcasting)
	// PATTERN: Publish-Subscribe for domain events
	natsClient, err := nats.NewClient(cfg.NatsURL)
	if err != nil {
		log.Error("NATS init failed", "error", err)
	} else {
		log.Info("NATS connected")
		defer natsClient.Close()
	}
	{{ end }}

	{{ if .HasS3 }}
	// --- S3-Compatible Storage Connection ---
	// ROLE: File/blob storage for attachments, images, documents
	// USED BY: Media service, attachment handlers
	s3Client, err := s3.New(ctx, cfg.AWSRegion, cfg.S3Bucket, cfg.S3Endpoint)
	if err != nil {
		log.Error("S3 init failed", "error", err)
	} else {
		log.Info("S3 initialized", "bucket", cfg.S3Bucket)
	}
	{{ end }}

	// Pre-declare variables for health handler to ensure they exist even if disabled
	{{ if not .HasSQL }}var pgPool *pgxpool.Pool{{ end }}
	{{ if not .HasNats }}var natsClient *nats.Client{{ end }}
	{{ if not (or .HasCache (or (eq .AuthRefreshStore "redis") (eq .AuthRefreshStore "hybrid"))) }}var redisClient *redis.Client{{ end }}

	{{ if .HasScheduler }}
	// --- Background Scheduler ---
	// ROLE: Execute periodic tasks (cleanup, notifications, etc.)
	// PUBLISHES: Scheduled events via NATS
	var publisher port.Publisher
	if natsClient != nil {
		publisher = natsClient
	}
	sched := scheduler.New(publisher, scheduler.DefaultSchedules)
	sched.Start(ctx)
	{{ end }}

	// ========================================================================
	// SECTION: HTTP Router & Middleware Chain
	// PURPOSE: Configure request processing pipeline
	// MIDDLEWARE ORDER: RequestID -> Tracing -> Metrics -> Logging -> Recovery -> CORS
	// ========================================================================
	r := chi.NewRouter()
	r.Use(middleware.RequestID)
	r.Use(otelhttp.NewMiddleware("ang-service"))
	r.Use(transport.MetricsMiddleware)
	r.Use(transport.LoggingMiddleware)
	r.Use(middleware.Recoverer)

	// CORS configuration - allows cross-origin requests from frontend apps
	corsMiddleware := cors.New(cors.Options{
		AllowedOrigins:   []string{"*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"*"},
		ExposedHeaders:   []string{"Link", "X-Total-Count"},
		AllowCredentials: false,
		MaxAge:           300,
	})
	r.Use(corsMiddleware.Handler)

	// Prometheus metrics endpoint for monitoring
	r.Handle("/metrics", promhttp.Handler())

	// ========================================================================
	// SECTION: Dependency Injection - Repositories
	// PURPOSE: Instantiate data access layer (Repository pattern)
	// PATTERN: Each repository wraps pgPool and provides CRUD for one entity
	// NAMING: repo{EntityName} (e.g., repoUser, repoTender, repoCompany)
	// ========================================================================
	{{- $needsRefreshStore := ne $.AuthService "" }}
	{{- if $needsRefreshStore }}
	// Auth refresh token store (for JWT refresh token persistence)
	var refreshStore port.RefreshTokenStore
	{{- if eq $.AuthRefreshStore "memory" }}
	refreshStore = authstore.NewMemoryStore()
	{{- else if eq $.AuthRefreshStore "redis" }}
	refreshStore = authredis.NewStore(redisClient)
	{{- else if eq $.AuthRefreshStore "postgres" }}
	refreshStore = authpg.NewStore(pgPool)
	{{- else if eq $.AuthRefreshStore "hybrid" }}
	refreshStore = authhybrid.NewStore(authpg.NewStore(pgPool), authredis.NewStore(redisClient))
	{{- else }}
	refreshStore = authstore.NewMemoryStore()
	{{- end }}
	{{- end }}

	// Repository instances - one per domain entity
	{{- range AllRepoEntities .Entities }}
	{{- if eq (EntityStorageByName $.Entities .) "mongo" }}
	repo{{ ExportName . }} := mongorepo.New{{ ExportName . }}Repository(mongoClient, cfg.MongoDatabase)
	{{- else }}
	repo{{ ExportName . }} := postgres.New{{ ExportName . }}Repository(pgPool)
	{{- end }}
	{{- end }}

	{{- if AnyServiceHasIdempotencyOrOutbox .Services }}
	// System repository for Outbox and Idempotency
	repoSystem := postgres.NewSystemRepository(pgPool)
	{{- end }}

	{{- if HasTxServices .Services }}
	// Transaction manager for multi-repository operations
	txManager := postgres.NewTxManager(pgPool)
	{{- end }}

	// ========================================================================
	// SECTION: Dependency Injection - Services
	// PURPOSE: Instantiate business logic layer (Service pattern)
	// PATTERN: Each service receives its dependencies via constructor injection
	// NAMING: svc{ServiceName} (e.g., svcAuth, svcTender, svcCompany)
	// DEPENDENCIES: repositories, txManager, publisher (NATS), storage (S3)
	// ========================================================================
	// --- Audit Service (Dependency for all other services) ---
	svcAudit := service.NewAuditImpl(repoAuditLog)

	{{- range .Services }}
		{{- $svc := . }}
		{{- if ne .Name "Audit" }}
	// --- {{ .Name }} Service ---
	svc{{ .Name }} := service.New{{ .Name }}Impl(
		{{- range getRepoEntities . }}
		repo{{ ExportName . }},
		{{- end }}
		{{- range getServiceDeps . }}
		svc{{ ExportName . }},
		{{- end }}
		{{- if ServiceNeedsTx . }}
		txManager,
		{{- end }}
		{{- if and $.AuthService (eq $.AuthService .Name) }}
		cfg,
		refreshStore,
		{{- end }}
		{{- if ServiceHasPublishes . }}
		natsClient,
		{{- end }}
		{{- if ServiceHasIdempotency . }}
		repoSystem,
		{{- end }}
		{{- if ServiceHasOutbox . }}
		repoSystem,
		{{- end }}
		svcAudit,
		{{- if .RequiresS3 }}
		s3Client,
		{{- end }}
	)
		{{- end }}

	{{ if $svc.Subscribes }}
	// ========================================================================
	// SECTION: Event Subscriptions for {{ .Name }} Service
	// ========================================================================
	if natsClient != nil {
	{{- range $evtName := sortedKeys $svc.Subscribes }}
	{{- $method := mapGet $svc.Subscribes $evtName }}
		// EVENT: {{ $evtName }} -> {{ $svc.Name }}.{{ $method }}()
		if _, err := natsClient.Subscribe("{{ $evtName }}", func(data []byte) error {
			var event port.{{ $method }}Request
			if err := json.Unmarshal(data, &event); err != nil {
				return err
			}
			if _, err := svc{{ $svc.Name }}.{{ $method }}(context.Background(), event); err != nil {
				return err
			}
			return nil
		}); err != nil {
			log.Error("Failed to subscribe to {{ $evtName }}", "error", err)
		}
	{{- end }}
	}
	{{ end }}

	// Register HTTP routes for {{ .Name }} service
	transport.Register{{ .Name }}Routes(r, svc{{ .Name }})
	{{- if index $.WebSocketServices .Name }}
	// Register WebSocket routes for {{ .Name }} service (real-time updates)
	transport.Register{{ .Name }}WSRoutes(r, svc{{ .Name }})
	{{- end }}
{{- end }}

	{{- if .HasNats }}
	// ========================================================================
	// SECTION: WebSocket Event Broadcasting
	// PURPOSE: Push real-time updates to connected WebSocket clients
	// PATTERN: NATS event -> deserialize -> broadcast to room/all clients
	// LAYER: Infrastructure (transparent to business logic)
	// ========================================================================
	if natsClient != nil {
		{{- range $svcName, $events := .WSEventMap }}
		{{- range $evtName, $evtFields := $events }}
		{{- $roomField := RoomFieldForEvent $.Endpoints $.Services $svcName $evtName }}
		{{- $hasRoomField := HasEventField $.EventPayloads $evtName $roomField }}
		// EVENT: {{ $evtName }} -> WebSocket broadcast
		{{- if and $roomField $hasRoomField }}
		// ROOM: Scoped by {{ $roomField }} field (only clients in that room receive)
		{{- else }}
		// ROOM: Global broadcast (all connected clients)
		{{- end }}
		if _, err := natsClient.Subscribe("{{ $evtName }}", func(data []byte) error {
			var event domain.{{ ExportName $evtName }}
			if err := json.Unmarshal(data, &event); err != nil {
				return err
			}
			{{- if and $roomField $hasRoomField }}
			transport.Broadcast{{ $evtName }}(event.{{ $roomField | ExportName }}, event)
			{{- else }}
			transport.Broadcast{{ $evtName }}("", event)
			{{- end }}
			return nil
		}); err != nil {
			log.Error("Failed to subscribe to {{ $evtName }}", "error", err)
		}
		{{- end }}
		{{- end }}
	}
	{{- end }}

	// Health & Readiness probes
	r.Get("/health", transport.HealthHandler())
	r.Get("/health/ready", transport.ReadinessHandler(pgPool, redisClient, natsClient))

	// Prometheus metrics endpoint for monitoring
	r.Handle("/metrics", promhttp.Handler())

	// ========================================================================
	// SECTION: HTTP Server Lifecycle
	// PURPOSE: Start server and handle graceful shutdown
	// SHUTDOWN: Waits for SIGINT/SIGTERM, then gracefully closes connections
	// ========================================================================
	srv := &http.Server{
		Addr:    ":" + cfg.HTTPPort,
		Handler: r,
	}

	go func() {
		log.Info("Starting HTTP server", "addr", srv.Addr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Error("HTTP listen failed", "error", err)
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Info("Shutting down server...")

	// Graceful shutdown with timeout
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := srv.Shutdown(shutdownCtx); err != nil {
		log.Error("Server shutdown failed", "error", err)
	}

	{{- range $name, $enabled := .WebSocketServices }}
	{{- if $enabled }}
	transport.Stop{{ $name }}Hub()
	{{- end }}
	{{- end }}
}
