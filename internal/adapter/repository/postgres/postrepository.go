// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: postgres_repo.tmpl
// Repository: PostRepository
// Entity: Post
// Table: posts
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: 0.1.82
// InputHash: c512a5349e78b6ec2b981dae1900e24fdecd5fb628dcf797d5030b1fee38380f
// CompilerHash: c3fb900bcf4a303db1bd1e04238e5eaf59531dcb088354b4221baf991436313c
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package postgres

// ============================================================================
// SECTION: Imports
// PURPOSE: Database driver and domain entity imports
// ============================================================================
import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/strogmv/ang/internal/domain"
)

// ============================================================================
// SECTION: Repository Struct
// PURPOSE: PostRepository provides data access for Post entity
// PATTERN: Repository Pattern - abstracts data persistence from business logic
// TABLE: posts
// INTERFACE: Implements port.PostRepository
// ============================================================================
type PostRepository struct {
	DB *pgxpool.Pool
}

// ============================================================================
// SECTION: Constructor
// PURPOSE: Create repository with database pool connection
// USAGE: Called from main.go during application bootstrap
// ============================================================================
func NewPostRepository(db *pgxpool.Pool) *PostRepository {
	return &PostRepository{DB: db}
}

// ============================================================================
// METHOD: Save
// PURPOSE: Persist entity to database (INSERT or UPDATE via upsert)
// PATTERN: Upsert - uses ON CONFLICT DO UPDATE for idempotent writes
// SQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
// ============================================================================
func (r *PostRepository) Save(ctx context.Context, entity *domain.Post) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if err := entity.Validate(); err != nil {
		return fmt.Errorf("invalid entity: %w", err)
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `
		INSERT INTO posts (id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
		ON CONFLICT (id) DO UPDATE
		SET authorid = EXCLUDED.authorid, title = EXCLUDED.title, slug = EXCLUDED.slug, content = EXCLUDED.content, excerpt = EXCLUDED.excerpt, status = EXCLUDED.status, publishedat = EXCLUDED.publishedat, viewcount = EXCLUDED.viewcount, createdat = EXCLUDED.createdat, updatedat = EXCLUDED.updatedat
	`, entity.ID, entity.AuthorID, entity.Title, entity.Slug, entity.Content, entity.Excerpt, entity.Status, entity.PublishedAt, entity.ViewCount, entity.CreatedAt, entity.UpdatedAt)
	return err
}

// ============================================================================
// METHOD: FindByID
// PURPOSE: Retrieve single entity by primary key
// RETURNS: *entity or nil if not found (nil, nil means not found)
// SQL: SELECT ... FROM posts WHERE id = $1
// ============================================================================
func (r *PostRepository) FindByID(ctx context.Context, id string) (*domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat::text, viewcount, createdat::text, updatedat::text
		FROM posts
		WHERE id = $1
		LIMIT 1
	`, id)
	var entity domain.Post
	var idVal string
	var authoridVal string
	var titleVal string
	var slugVal string
	var contentVal string
	var excerptVal string
	var statusVal string
	var publishedatVal time.Time
	var viewcountVal int
	var createdatVal time.Time
	var updatedatVal time.Time
	if err := row.Scan(
		&idVal,
		&authoridVal,
		&titleVal,
		&slugVal,
		&contentVal,
		&excerptVal,
		&statusVal,
		&publishedatVal,
		&viewcountVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByID scan: %w", err)
	}
	entity.ID = idVal
	entity.AuthorID = authoridVal
	entity.Title = titleVal
	entity.Slug = slugVal
	entity.Content = contentVal
	entity.Excerpt = excerptVal
	entity.Status = statusVal
	entity.PublishedAt = publishedatVal
	entity.ViewCount = viewcountVal
	entity.CreatedAt = createdatVal
	entity.UpdatedAt = updatedatVal
	return &entity, nil
}

// ============================================================================
// METHOD: Delete
// PURPOSE: Remove entity from database by primary key
// SQL: DELETE FROM posts WHERE id = $1
// ============================================================================
func (r *PostRepository) Delete(ctx context.Context, id string) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `DELETE FROM posts WHERE id = $1`, id)
	return err
}

// ============================================================================
// METHOD: ListAll
// PURPOSE: Retrieve paginated list of all entities
// SQL: SELECT ... FROM posts ORDER BY id LIMIT $1 OFFSET $2
// ============================================================================
func (r *PostRepository) ListAll(ctx context.Context, offset, limit int) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat::text, viewcount, createdat::text, updatedat::text
		FROM posts
		ORDER BY id
		LIMIT $1 OFFSET $2
	`, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("ListAll query: %w", err)
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal string
		var authoridVal string
		var titleVal string
		var slugVal string
		var contentVal string
		var excerptVal string
		var statusVal string
		var publishedatVal time.Time
		var viewcountVal int
		var createdatVal time.Time
		var updatedatVal time.Time
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, fmt.Errorf("ListAll scan: %w", err)
		}
		entity.ID = idVal
		entity.AuthorID = authoridVal
		entity.Title = titleVal
		entity.Slug = slugVal
		entity.Content = contentVal
		entity.Excerpt = excerptVal
		entity.Status = statusVal
		entity.PublishedAt = publishedatVal
		entity.ViewCount = viewcountVal
		entity.CreatedAt = createdatVal
		entity.UpdatedAt = updatedatVal
		items = append(items, entity)
	}
	return items, nil
}

// ============================================================================
// SECTION: Custom Finder Methods
// PURPOSE: Query methods defined in CUE repository configuration
// PATTERN: Each finder generates SELECT with specific WHERE/ORDER BY clauses
// ============================================================================
// FINDER: FindBySlug
// PARAMS: slug string
// RETURNS: *domain.Post
func (r *PostRepository) FindBySlug(ctx context.Context, slug string) (*domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat::text, viewcount, createdat::text, updatedat::text
		FROM posts
		WHERE slug = $1
		LIMIT 1
	`, slug)
	var entity domain.Post
	var idVal string
	var authoridVal string
	var titleVal string
	var slugVal string
	var contentVal string
	var excerptVal string
	var statusVal string
	var publishedatVal time.Time
	var viewcountVal int
	var createdatVal time.Time
	var updatedatVal time.Time
	if err := row.Scan(
		&idVal,
		&authoridVal,
		&titleVal,
		&slugVal,
		&contentVal,
		&excerptVal,
		&statusVal,
		&publishedatVal,
		&viewcountVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindBySlug scan: %w", err)
	}
	entity.ID = idVal
	entity.AuthorID = authoridVal
	entity.Title = titleVal
	entity.Slug = slugVal
	entity.Content = contentVal
	entity.Excerpt = excerptVal
	entity.Status = statusVal
	entity.PublishedAt = publishedatVal
	entity.ViewCount = viewcountVal
	entity.CreatedAt = createdatVal
	entity.UpdatedAt = updatedatVal
	return &entity, nil
}

// FINDER: ListPublished
// PARAMS: status string
// RETURNS: []domain.Post
func (r *PostRepository) ListPublished(ctx context.Context, status string) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat::text, viewcount, createdat::text, updatedat::text
		FROM posts
		WHERE status = $1
		ORDER BY published_at DESC
	`, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal string
		var authoridVal string
		var titleVal string
		var slugVal string
		var contentVal string
		var excerptVal string
		var statusVal string
		var publishedatVal time.Time
		var viewcountVal int
		var createdatVal time.Time
		var updatedatVal time.Time
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		entity.ID = idVal
		entity.AuthorID = authoridVal
		entity.Title = titleVal
		entity.Slug = slugVal
		entity.Content = contentVal
		entity.Excerpt = excerptVal
		entity.Status = statusVal
		entity.PublishedAt = publishedatVal
		entity.ViewCount = viewcountVal
		entity.CreatedAt = createdatVal
		entity.UpdatedAt = updatedatVal
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: CountPublished
// PARAMS: status string
// RETURNS: int64
func (r *PostRepository) CountPublished(ctx context.Context, status string) (int64, error) {
	if r.DB == nil {
		return 0, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM posts
		WHERE status = $1
		LIMIT 1
	`, status)
	var v int64
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return 0, nil
		}
		return 0, err
	}
	return v, nil
}

// FINDER: ListPublishedByTag
// PARAMS: status string, id string
// RETURNS: []domain.Post
func (r *PostRepository) ListPublishedByTag(ctx context.Context, status string, id string) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat::text, viewcount, createdat::text, updatedat::text
		FROM posts
		WHERE status = $1 AND id IN $2
		ORDER BY published_at DESC
	`, status, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal string
		var authoridVal string
		var titleVal string
		var slugVal string
		var contentVal string
		var excerptVal string
		var statusVal string
		var publishedatVal time.Time
		var viewcountVal int
		var createdatVal time.Time
		var updatedatVal time.Time
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		entity.ID = idVal
		entity.AuthorID = authoridVal
		entity.Title = titleVal
		entity.Slug = slugVal
		entity.Content = contentVal
		entity.Excerpt = excerptVal
		entity.Status = statusVal
		entity.PublishedAt = publishedatVal
		entity.ViewCount = viewcountVal
		entity.CreatedAt = createdatVal
		entity.UpdatedAt = updatedatVal
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: CountPublishedByTag
// PARAMS: status string, id string
// RETURNS: int64
func (r *PostRepository) CountPublishedByTag(ctx context.Context, status string, id string) (int64, error) {
	if r.DB == nil {
		return 0, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM posts
		WHERE status = $1 AND id IN $2
		LIMIT 1
	`, status, id)
	var v int64
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return 0, nil
		}
		return 0, err
	}
	return v, nil
}

// FINDER: ListByAuthor
// PARAMS: authorID string
// RETURNS: []domain.Post
func (r *PostRepository) ListByAuthor(ctx context.Context, authorID string) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat::text, viewcount, createdat::text, updatedat::text
		FROM posts
		WHERE author_id = $1
		ORDER BY created_at DESC
	`, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal string
		var authoridVal string
		var titleVal string
		var slugVal string
		var contentVal string
		var excerptVal string
		var statusVal string
		var publishedatVal time.Time
		var viewcountVal int
		var createdatVal time.Time
		var updatedatVal time.Time
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		entity.ID = idVal
		entity.AuthorID = authoridVal
		entity.Title = titleVal
		entity.Slug = slugVal
		entity.Content = contentVal
		entity.Excerpt = excerptVal
		entity.Status = statusVal
		entity.PublishedAt = publishedatVal
		entity.ViewCount = viewcountVal
		entity.CreatedAt = createdatVal
		entity.UpdatedAt = updatedatVal
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: ListByAuthorAndStatus
// PARAMS: authorID string, status string
// RETURNS: []domain.Post
func (r *PostRepository) ListByAuthorAndStatus(ctx context.Context, authorID string, status string) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat::text, viewcount, createdat::text, updatedat::text
		FROM posts
		WHERE author_id = $1 AND status = $2
		ORDER BY created_at DESC
	`, authorID, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal string
		var authoridVal string
		var titleVal string
		var slugVal string
		var contentVal string
		var excerptVal string
		var statusVal string
		var publishedatVal time.Time
		var viewcountVal int
		var createdatVal time.Time
		var updatedatVal time.Time
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		entity.ID = idVal
		entity.AuthorID = authoridVal
		entity.Title = titleVal
		entity.Slug = slugVal
		entity.Content = contentVal
		entity.Excerpt = excerptVal
		entity.Status = statusVal
		entity.PublishedAt = publishedatVal
		entity.ViewCount = viewcountVal
		entity.CreatedAt = createdatVal
		entity.UpdatedAt = updatedatVal
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Ensure optional field scanners are referenced.
var _ = sql.NullString{}
