// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: postgres_repo.tmpl
// Repository: UserRepository
// Entity: User
// Table: users
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: 0.1.51
// InputHash: 027eaf3d0fffed4e5d3dbe6c68942a856acd710227485d4e2e76bb27357fa14a
// CompilerHash: 08a642c084b87d9392c0c2534fdbe0ff4b08989904e030ab4a5d545a605fc59c
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package postgres

// ============================================================================
// SECTION: Imports
// PURPOSE: Database driver and domain entity imports
// ============================================================================
import (
	"context"
	"database/sql"
	"fmt"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/strogmv/ang/internal/domain"
)

// ============================================================================
// SECTION: Repository Struct
// PURPOSE: UserRepository provides data access for User entity
// PATTERN: Repository Pattern - abstracts data persistence from business logic
// TABLE: users
// INTERFACE: Implements port.UserRepository
// ============================================================================
type UserRepository struct {
	DB *pgxpool.Pool
}

// ============================================================================
// SECTION: Constructor
// PURPOSE: Create repository with database pool connection
// USAGE: Called from main.go during application bootstrap
// ============================================================================
func NewUserRepository(db *pgxpool.Pool) *UserRepository {
	return &UserRepository{DB: db}
}

// ============================================================================
// METHOD: Save
// PURPOSE: Persist entity to database (INSERT or UPDATE via upsert)
// PATTERN: Upsert - uses ON CONFLICT DO UPDATE for idempotent writes
// SQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
// ============================================================================
func (r *UserRepository) Save(ctx context.Context, entity *domain.User) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if err := entity.Validate(); err != nil {
		return fmt.Errorf("invalid entity: %w", err)
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `
		INSERT INTO users (id, email, phonenumber, passwordhash, name, role, avatarurl, createdat, updatedat)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
		ON CONFLICT (id) DO UPDATE
		SET email = EXCLUDED.email, phonenumber = EXCLUDED.phonenumber, passwordhash = EXCLUDED.passwordhash, name = EXCLUDED.name, role = EXCLUDED.role, avatarurl = EXCLUDED.avatarurl, createdat = EXCLUDED.createdat, updatedat = EXCLUDED.updatedat
	`, entity.ID, entity.Email, nullJSON(entity.PhoneNumber), entity.PasswordHash, entity.Name, entity.Role, entity.AvatarURL, entity.CreatedAt, entity.UpdatedAt)
	return err
}

// ============================================================================
// METHOD: FindByID
// PURPOSE: Retrieve single entity by primary key
// RETURNS: *entity or nil if not found (nil, nil means not found)
// SQL: SELECT ... FROM users WHERE id = $1
// ============================================================================
func (r *UserRepository) FindByID(ctx context.Context, id string) (*domain.User, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, email, phonenumber, passwordhash, name, role, avatarurl, createdat, updatedat
		FROM users
		WHERE id = $1
		LIMIT 1
	`, id)
	var entity domain.User
	var idVal sql.NullString
	var emailVal sql.NullString
	var phonenumberVal sql.NullString
	var passwordhashVal sql.NullString
	var nameVal sql.NullString
	var roleVal sql.NullString
	var avatarurlVal sql.NullString
	var createdatVal sql.NullString
	var updatedatVal sql.NullString
	if err := row.Scan(
		&idVal,
		&emailVal,
		&phonenumberVal,
		&passwordhashVal,
		&nameVal,
		&roleVal,
		&avatarurlVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByID scan: %w", err)
	}
	if idVal.Valid {
		unmarshalJSON(idVal.String, &entity.ID)
	}
	if emailVal.Valid {
		unmarshalJSON(emailVal.String, &entity.Email)
	}
	if phonenumberVal.Valid {
		unmarshalJSON(phonenumberVal.String, &entity.PhoneNumber)
	}
	if passwordhashVal.Valid {
		unmarshalJSON(passwordhashVal.String, &entity.PasswordHash)
	}
	if nameVal.Valid {
		unmarshalJSON(nameVal.String, &entity.Name)
	}
	if roleVal.Valid {
		unmarshalJSON(roleVal.String, &entity.Role)
	}
	if avatarurlVal.Valid {
		unmarshalJSON(avatarurlVal.String, &entity.AvatarURL)
	}
	if createdatVal.Valid {
		unmarshalJSON(createdatVal.String, &entity.CreatedAt)
	}
	if updatedatVal.Valid {
		unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
	}
	return &entity, nil
}

// ============================================================================
// METHOD: Delete
// PURPOSE: Remove entity from database by primary key
// SQL: DELETE FROM users WHERE id = $1
// ============================================================================
func (r *UserRepository) Delete(ctx context.Context, id string) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `DELETE FROM users WHERE id = $1`, id)
	return err
}

// ============================================================================
// METHOD: ListAll
// PURPOSE: Retrieve paginated list of all entities
// SQL: SELECT ... FROM users ORDER BY id LIMIT $1 OFFSET $2
// ============================================================================
func (r *UserRepository) ListAll(ctx context.Context, offset, limit int) ([]domain.User, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, email, phonenumber, passwordhash, name, role, avatarurl, createdat, updatedat
		FROM users
		ORDER BY id
		LIMIT $1 OFFSET $2
	`, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("ListAll query: %w", err)
	}
	defer rows.Close()
	var items []domain.User
	for rows.Next() {
		var entity domain.User
		var idVal sql.NullString
		var emailVal sql.NullString
		var phonenumberVal sql.NullString
		var passwordhashVal sql.NullString
		var nameVal sql.NullString
		var roleVal sql.NullString
		var avatarurlVal sql.NullString
		var createdatVal sql.NullString
		var updatedatVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&emailVal,
			&phonenumberVal,
			&passwordhashVal,
			&nameVal,
			&roleVal,
			&avatarurlVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, fmt.Errorf("ListAll scan: %w", err)
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if emailVal.Valid {
			unmarshalJSON(emailVal.String, &entity.Email)
		}
		if phonenumberVal.Valid {
			unmarshalJSON(phonenumberVal.String, &entity.PhoneNumber)
		}
		if passwordhashVal.Valid {
			unmarshalJSON(passwordhashVal.String, &entity.PasswordHash)
		}
		if nameVal.Valid {
			unmarshalJSON(nameVal.String, &entity.Name)
		}
		if roleVal.Valid {
			unmarshalJSON(roleVal.String, &entity.Role)
		}
		if avatarurlVal.Valid {
			unmarshalJSON(avatarurlVal.String, &entity.AvatarURL)
		}
		if createdatVal.Valid {
			unmarshalJSON(createdatVal.String, &entity.CreatedAt)
		}
		if updatedatVal.Valid {
			unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
		}
		items = append(items, entity)
	}
	return items, nil
}

// ============================================================================
// SECTION: Custom Finder Methods
// PURPOSE: Query methods defined in CUE repository configuration
// PATTERN: Each finder generates SELECT with specific WHERE/ORDER BY clauses
// ============================================================================
// FINDER: FindByEmail
// PARAMS: email map[string]any
// RETURNS: *domain.User
func (r *UserRepository) FindByEmail(ctx context.Context, email map[string]any) (*domain.User, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, email, phonenumber, passwordhash, name, role, avatarurl, createdat, updatedat
		FROM users
		WHERE email = $1
		LIMIT 1
	`, email)
	var entity domain.User
	var idVal sql.NullString
	var emailVal sql.NullString
	var phonenumberVal sql.NullString
	var passwordhashVal sql.NullString
	var nameVal sql.NullString
	var roleVal sql.NullString
	var avatarurlVal sql.NullString
	var createdatVal sql.NullString
	var updatedatVal sql.NullString
	if err := row.Scan(
		&idVal,
		&emailVal,
		&phonenumberVal,
		&passwordhashVal,
		&nameVal,
		&roleVal,
		&avatarurlVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByEmail scan: %w", err)
	}
	if idVal.Valid {
		unmarshalJSON(idVal.String, &entity.ID)
	}
	if emailVal.Valid {
		unmarshalJSON(emailVal.String, &entity.Email)
	}
	if phonenumberVal.Valid {
		unmarshalJSON(phonenumberVal.String, &entity.PhoneNumber)
	}
	if passwordhashVal.Valid {
		unmarshalJSON(passwordhashVal.String, &entity.PasswordHash)
	}
	if nameVal.Valid {
		unmarshalJSON(nameVal.String, &entity.Name)
	}
	if roleVal.Valid {
		unmarshalJSON(roleVal.String, &entity.Role)
	}
	if avatarurlVal.Valid {
		unmarshalJSON(avatarurlVal.String, &entity.AvatarURL)
	}
	if createdatVal.Valid {
		unmarshalJSON(createdatVal.String, &entity.CreatedAt)
	}
	if updatedatVal.Valid {
		unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
	}
	return &entity, nil
}

// Ensure optional field scanners are referenced.
var _ = sql.NullString{}
