// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: postgres_repo.tmpl
// Repository: PostRepository
// Entity: Post
// Table: posts
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: 0.1.43
// InputHash: 4d22593cd3717a05651c0fd9db8039904fb5f3fb88dad299216dd00bfcb3bbad
// CompilerHash: e5cd89423d770d4d34dfbc0dd5935877609cb707582c9912adb39a5cd27f7a6c
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package postgres

// ============================================================================
// SECTION: Imports
// PURPOSE: Database driver and domain entity imports
// ============================================================================
import (
	"context"
	"database/sql"
	"fmt"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/strogmv/ang/internal/domain"
)

// ============================================================================
// SECTION: Repository Struct
// PURPOSE: PostRepository provides data access for Post entity
// PATTERN: Repository Pattern - abstracts data persistence from business logic
// TABLE: posts
// INTERFACE: Implements port.PostRepository
// ============================================================================
type PostRepository struct {
	DB *pgxpool.Pool
}

// ============================================================================
// SECTION: Constructor
// PURPOSE: Create repository with database pool connection
// USAGE: Called from main.go during application bootstrap
// ============================================================================
func NewPostRepository(db *pgxpool.Pool) *PostRepository {
	return &PostRepository{DB: db}
}

// ============================================================================
// METHOD: Save
// PURPOSE: Persist entity to database (INSERT or UPDATE via upsert)
// PATTERN: Upsert - uses ON CONFLICT DO UPDATE for idempotent writes
// SQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
// ============================================================================
func (r *PostRepository) Save(ctx context.Context, entity *domain.Post) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if err := entity.Validate(); err != nil {
		return fmt.Errorf("invalid entity: %w", err)
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `
		INSERT INTO posts (id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
		ON CONFLICT (id) DO UPDATE
		SET authorid = EXCLUDED.authorid, title = EXCLUDED.title, slug = EXCLUDED.slug, content = EXCLUDED.content, excerpt = EXCLUDED.excerpt, status = EXCLUDED.status, publishedat = EXCLUDED.publishedat, viewcount = EXCLUDED.viewcount, createdat = EXCLUDED.createdat, updatedat = EXCLUDED.updatedat
	`, entity.ID, entity.AuthorID, entity.Title, entity.Slug, entity.Content, entity.Excerpt, entity.Status, entity.PublishedAt, entity.ViewCount, entity.CreatedAt, entity.UpdatedAt)
	return err
}

// ============================================================================
// METHOD: FindByID
// PURPOSE: Retrieve single entity by primary key
// RETURNS: *entity or nil if not found (nil, nil means not found)
// SQL: SELECT ... FROM posts WHERE id = $1
// ============================================================================
func (r *PostRepository) FindByID(ctx context.Context, id string) (*domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE id = $1
		LIMIT 1
	`, id)
	var entity domain.Post
	if err := row.Scan(
		&entity.ID,
		&entity.AuthorID,
		&entity.Title,
		&entity.Slug,
		&entity.Content,
		&entity.Excerpt,
		&entity.Status,
		&entity.PublishedAt,
		&entity.ViewCount,
		&entity.CreatedAt,
		&entity.UpdatedAt,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByID scan: %w", err)
	}
	return &entity, nil
}

// ============================================================================
// METHOD: Delete
// PURPOSE: Remove entity from database by primary key
// SQL: DELETE FROM posts WHERE id = $1
// ============================================================================
func (r *PostRepository) Delete(ctx context.Context, id string) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `DELETE FROM posts WHERE id = $1`, id)
	return err
}

// ============================================================================
// METHOD: ListAll
// PURPOSE: Retrieve paginated list of all entities
// SQL: SELECT ... FROM posts ORDER BY id LIMIT $1 OFFSET $2
// ============================================================================
func (r *PostRepository) ListAll(ctx context.Context, offset, limit int) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		ORDER BY id
		LIMIT $1 OFFSET $2
	`, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("ListAll query: %w", err)
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		if err := rows.Scan(
			&entity.ID,
			&entity.AuthorID,
			&entity.Title,
			&entity.Slug,
			&entity.Content,
			&entity.Excerpt,
			&entity.Status,
			&entity.PublishedAt,
			&entity.ViewCount,
			&entity.CreatedAt,
			&entity.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("ListAll scan: %w", err)
		}
		items = append(items, entity)
	}
	return items, nil
}

// ============================================================================
// SECTION: Custom Finder Methods
// PURPOSE: Query methods defined in CUE repository configuration
// PATTERN: Each finder generates SELECT with specific WHERE/ORDER BY clauses
// ============================================================================
// FINDER: FindBySlug
// PARAMS: slug map[string]any
// RETURNS: *domain.Post
func (r *PostRepository) FindBySlug(ctx context.Context, slug map[string]any) (*domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE slug = $1
		LIMIT 1
	`, slug)
	var entity domain.Post
	if err := row.Scan(
		&entity.ID,
		&entity.AuthorID,
		&entity.Title,
		&entity.Slug,
		&entity.Content,
		&entity.Excerpt,
		&entity.Status,
		&entity.PublishedAt,
		&entity.ViewCount,
		&entity.CreatedAt,
		&entity.UpdatedAt,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindBySlug scan: %w", err)
	}
	return &entity, nil
}

// FINDER: ListPublished
// PARAMS: status map[string]any
// RETURNS: []domain.Post
func (r *PostRepository) ListPublished(ctx context.Context, status map[string]any) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE status = $1
		ORDER BY published_at DESC
	`, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		if err := rows.Scan(
			&entity.ID,
			&entity.AuthorID,
			&entity.Title,
			&entity.Slug,
			&entity.Content,
			&entity.Excerpt,
			&entity.Status,
			&entity.PublishedAt,
			&entity.ViewCount,
			&entity.CreatedAt,
			&entity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: CountPublished
// PARAMS: status map[string]any
// RETURNS: int64
func (r *PostRepository) CountPublished(ctx context.Context, status map[string]any) (int64, error) {
	if r.DB == nil {
		return 0, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM posts
		WHERE status = $1
		LIMIT 1
	`, status)
	var v int64
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return 0, nil
		}
		return 0, err
	}
	return v, nil
}

// FINDER: ListPublishedByTag
// PARAMS: status map[string]any, id map[string]any
// RETURNS: []domain.Post
func (r *PostRepository) ListPublishedByTag(ctx context.Context, status map[string]any, id map[string]any) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE status = $1 AND id IN $2
		ORDER BY published_at DESC
	`, status, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		if err := rows.Scan(
			&entity.ID,
			&entity.AuthorID,
			&entity.Title,
			&entity.Slug,
			&entity.Content,
			&entity.Excerpt,
			&entity.Status,
			&entity.PublishedAt,
			&entity.ViewCount,
			&entity.CreatedAt,
			&entity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: CountPublishedByTag
// PARAMS: status map[string]any, id map[string]any
// RETURNS: int64
func (r *PostRepository) CountPublishedByTag(ctx context.Context, status map[string]any, id map[string]any) (int64, error) {
	if r.DB == nil {
		return 0, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM posts
		WHERE status = $1 AND id IN $2
		LIMIT 1
	`, status, id)
	var v int64
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return 0, nil
		}
		return 0, err
	}
	return v, nil
}

// FINDER: ListByAuthor
// PARAMS: authorID string
// RETURNS: []domain.Post
func (r *PostRepository) ListByAuthor(ctx context.Context, authorID string) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE author_id = $1
		ORDER BY created_at DESC
	`, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		if err := rows.Scan(
			&entity.ID,
			&entity.AuthorID,
			&entity.Title,
			&entity.Slug,
			&entity.Content,
			&entity.Excerpt,
			&entity.Status,
			&entity.PublishedAt,
			&entity.ViewCount,
			&entity.CreatedAt,
			&entity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: ListByAuthorAndStatus
// PARAMS: authorID string, status map[string]any
// RETURNS: []domain.Post
func (r *PostRepository) ListByAuthorAndStatus(ctx context.Context, authorID string, status map[string]any) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE author_id = $1 AND status = $2
		ORDER BY created_at DESC
	`, authorID, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		if err := rows.Scan(
			&entity.ID,
			&entity.AuthorID,
			&entity.Title,
			&entity.Slug,
			&entity.Content,
			&entity.Excerpt,
			&entity.Status,
			&entity.PublishedAt,
			&entity.ViewCount,
			&entity.CreatedAt,
			&entity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Ensure optional field scanners are referenced.
var _ = sql.NullString{}
