// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: postgres_repo.tmpl
// Repository: PostRepository
// Entity: Post
// Table: posts
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: 0.1.51
// InputHash: 027eaf3d0fffed4e5d3dbe6c68942a856acd710227485d4e2e76bb27357fa14a
// CompilerHash: 08a642c084b87d9392c0c2534fdbe0ff4b08989904e030ab4a5d545a605fc59c
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package postgres

// ============================================================================
// SECTION: Imports
// PURPOSE: Database driver and domain entity imports
// ============================================================================
import (
	"context"
	"database/sql"
	"fmt"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/strogmv/ang/internal/domain"
)

// ============================================================================
// SECTION: Repository Struct
// PURPOSE: PostRepository provides data access for Post entity
// PATTERN: Repository Pattern - abstracts data persistence from business logic
// TABLE: posts
// INTERFACE: Implements port.PostRepository
// ============================================================================
type PostRepository struct {
	DB *pgxpool.Pool
}

// ============================================================================
// SECTION: Constructor
// PURPOSE: Create repository with database pool connection
// USAGE: Called from main.go during application bootstrap
// ============================================================================
func NewPostRepository(db *pgxpool.Pool) *PostRepository {
	return &PostRepository{DB: db}
}

// ============================================================================
// METHOD: Save
// PURPOSE: Persist entity to database (INSERT or UPDATE via upsert)
// PATTERN: Upsert - uses ON CONFLICT DO UPDATE for idempotent writes
// SQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
// ============================================================================
func (r *PostRepository) Save(ctx context.Context, entity *domain.Post) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if err := entity.Validate(); err != nil {
		return fmt.Errorf("invalid entity: %w", err)
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `
		INSERT INTO posts (id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
		ON CONFLICT (id) DO UPDATE
		SET authorid = EXCLUDED.authorid, title = EXCLUDED.title, slug = EXCLUDED.slug, content = EXCLUDED.content, excerpt = EXCLUDED.excerpt, status = EXCLUDED.status, publishedat = EXCLUDED.publishedat, viewcount = EXCLUDED.viewcount, createdat = EXCLUDED.createdat, updatedat = EXCLUDED.updatedat
	`, entity.ID, entity.AuthorID, entity.Title, entity.Slug, entity.Content, entity.Excerpt, entity.Status, entity.PublishedAt, entity.ViewCount, entity.CreatedAt, entity.UpdatedAt)
	return err
}

// ============================================================================
// METHOD: FindByID
// PURPOSE: Retrieve single entity by primary key
// RETURNS: *entity or nil if not found (nil, nil means not found)
// SQL: SELECT ... FROM posts WHERE id = $1
// ============================================================================
func (r *PostRepository) FindByID(ctx context.Context, id string) (*domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE id = $1
		LIMIT 1
	`, id)
	var entity domain.Post
	var idVal sql.NullString
	var authoridVal sql.NullString
	var titleVal sql.NullString
	var slugVal sql.NullString
	var contentVal sql.NullString
	var excerptVal sql.NullString
	var statusVal sql.NullString
	var publishedatVal sql.NullString
	var viewcountVal sql.NullString
	var createdatVal sql.NullString
	var updatedatVal sql.NullString
	if err := row.Scan(
		&idVal,
		&authoridVal,
		&titleVal,
		&slugVal,
		&contentVal,
		&excerptVal,
		&statusVal,
		&publishedatVal,
		&viewcountVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindByID scan: %w", err)
	}
	if idVal.Valid {
		unmarshalJSON(idVal.String, &entity.ID)
	}
	if authoridVal.Valid {
		unmarshalJSON(authoridVal.String, &entity.AuthorID)
	}
	if titleVal.Valid {
		unmarshalJSON(titleVal.String, &entity.Title)
	}
	if slugVal.Valid {
		unmarshalJSON(slugVal.String, &entity.Slug)
	}
	if contentVal.Valid {
		unmarshalJSON(contentVal.String, &entity.Content)
	}
	if excerptVal.Valid {
		unmarshalJSON(excerptVal.String, &entity.Excerpt)
	}
	if statusVal.Valid {
		unmarshalJSON(statusVal.String, &entity.Status)
	}
	if publishedatVal.Valid {
		unmarshalJSON(publishedatVal.String, &entity.PublishedAt)
	}
	if viewcountVal.Valid {
		unmarshalJSON(viewcountVal.String, &entity.ViewCount)
	}
	if createdatVal.Valid {
		unmarshalJSON(createdatVal.String, &entity.CreatedAt)
	}
	if updatedatVal.Valid {
		unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
	}
	return &entity, nil
}

// ============================================================================
// METHOD: Delete
// PURPOSE: Remove entity from database by primary key
// SQL: DELETE FROM posts WHERE id = $1
// ============================================================================
func (r *PostRepository) Delete(ctx context.Context, id string) error {
	if r.DB == nil {
		return fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	_, err := exec.Exec(ctx, `DELETE FROM posts WHERE id = $1`, id)
	return err
}

// ============================================================================
// METHOD: ListAll
// PURPOSE: Retrieve paginated list of all entities
// SQL: SELECT ... FROM posts ORDER BY id LIMIT $1 OFFSET $2
// ============================================================================
func (r *PostRepository) ListAll(ctx context.Context, offset, limit int) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		ORDER BY id
		LIMIT $1 OFFSET $2
	`, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("ListAll query: %w", err)
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal sql.NullString
		var authoridVal sql.NullString
		var titleVal sql.NullString
		var slugVal sql.NullString
		var contentVal sql.NullString
		var excerptVal sql.NullString
		var statusVal sql.NullString
		var publishedatVal sql.NullString
		var viewcountVal sql.NullString
		var createdatVal sql.NullString
		var updatedatVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, fmt.Errorf("ListAll scan: %w", err)
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if authoridVal.Valid {
			unmarshalJSON(authoridVal.String, &entity.AuthorID)
		}
		if titleVal.Valid {
			unmarshalJSON(titleVal.String, &entity.Title)
		}
		if slugVal.Valid {
			unmarshalJSON(slugVal.String, &entity.Slug)
		}
		if contentVal.Valid {
			unmarshalJSON(contentVal.String, &entity.Content)
		}
		if excerptVal.Valid {
			unmarshalJSON(excerptVal.String, &entity.Excerpt)
		}
		if statusVal.Valid {
			unmarshalJSON(statusVal.String, &entity.Status)
		}
		if publishedatVal.Valid {
			unmarshalJSON(publishedatVal.String, &entity.PublishedAt)
		}
		if viewcountVal.Valid {
			unmarshalJSON(viewcountVal.String, &entity.ViewCount)
		}
		if createdatVal.Valid {
			unmarshalJSON(createdatVal.String, &entity.CreatedAt)
		}
		if updatedatVal.Valid {
			unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
		}
		items = append(items, entity)
	}
	return items, nil
}

// ============================================================================
// SECTION: Custom Finder Methods
// PURPOSE: Query methods defined in CUE repository configuration
// PATTERN: Each finder generates SELECT with specific WHERE/ORDER BY clauses
// ============================================================================
// FINDER: FindBySlug
// PARAMS: slug map[string]any
// RETURNS: *domain.Post
func (r *PostRepository) FindBySlug(ctx context.Context, slug map[string]any) (*domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE slug = $1
		LIMIT 1
	`, slug)
	var entity domain.Post
	var idVal sql.NullString
	var authoridVal sql.NullString
	var titleVal sql.NullString
	var slugVal sql.NullString
	var contentVal sql.NullString
	var excerptVal sql.NullString
	var statusVal sql.NullString
	var publishedatVal sql.NullString
	var viewcountVal sql.NullString
	var createdatVal sql.NullString
	var updatedatVal sql.NullString
	if err := row.Scan(
		&idVal,
		&authoridVal,
		&titleVal,
		&slugVal,
		&contentVal,
		&excerptVal,
		&statusVal,
		&publishedatVal,
		&viewcountVal,
		&createdatVal,
		&updatedatVal,
	); err != nil {
		if err.Error() == "no rows in result set" {
			return nil, nil
		}
		return nil, fmt.Errorf("FindBySlug scan: %w", err)
	}
	if idVal.Valid {
		unmarshalJSON(idVal.String, &entity.ID)
	}
	if authoridVal.Valid {
		unmarshalJSON(authoridVal.String, &entity.AuthorID)
	}
	if titleVal.Valid {
		unmarshalJSON(titleVal.String, &entity.Title)
	}
	if slugVal.Valid {
		unmarshalJSON(slugVal.String, &entity.Slug)
	}
	if contentVal.Valid {
		unmarshalJSON(contentVal.String, &entity.Content)
	}
	if excerptVal.Valid {
		unmarshalJSON(excerptVal.String, &entity.Excerpt)
	}
	if statusVal.Valid {
		unmarshalJSON(statusVal.String, &entity.Status)
	}
	if publishedatVal.Valid {
		unmarshalJSON(publishedatVal.String, &entity.PublishedAt)
	}
	if viewcountVal.Valid {
		unmarshalJSON(viewcountVal.String, &entity.ViewCount)
	}
	if createdatVal.Valid {
		unmarshalJSON(createdatVal.String, &entity.CreatedAt)
	}
	if updatedatVal.Valid {
		unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
	}
	return &entity, nil
}

// FINDER: ListPublished
// PARAMS: status map[string]any
// RETURNS: []domain.Post
func (r *PostRepository) ListPublished(ctx context.Context, status map[string]any) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE status = $1
		ORDER BY published_at DESC
	`, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal sql.NullString
		var authoridVal sql.NullString
		var titleVal sql.NullString
		var slugVal sql.NullString
		var contentVal sql.NullString
		var excerptVal sql.NullString
		var statusVal sql.NullString
		var publishedatVal sql.NullString
		var viewcountVal sql.NullString
		var createdatVal sql.NullString
		var updatedatVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if authoridVal.Valid {
			unmarshalJSON(authoridVal.String, &entity.AuthorID)
		}
		if titleVal.Valid {
			unmarshalJSON(titleVal.String, &entity.Title)
		}
		if slugVal.Valid {
			unmarshalJSON(slugVal.String, &entity.Slug)
		}
		if contentVal.Valid {
			unmarshalJSON(contentVal.String, &entity.Content)
		}
		if excerptVal.Valid {
			unmarshalJSON(excerptVal.String, &entity.Excerpt)
		}
		if statusVal.Valid {
			unmarshalJSON(statusVal.String, &entity.Status)
		}
		if publishedatVal.Valid {
			unmarshalJSON(publishedatVal.String, &entity.PublishedAt)
		}
		if viewcountVal.Valid {
			unmarshalJSON(viewcountVal.String, &entity.ViewCount)
		}
		if createdatVal.Valid {
			unmarshalJSON(createdatVal.String, &entity.CreatedAt)
		}
		if updatedatVal.Valid {
			unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: CountPublished
// PARAMS: status map[string]any
// RETURNS: int64
func (r *PostRepository) CountPublished(ctx context.Context, status map[string]any) (int64, error) {
	if r.DB == nil {
		return 0, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM posts
		WHERE status = $1
		LIMIT 1
	`, status)
	var v int64
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return 0, nil
		}
		return 0, err
	}
	return v, nil
}

// FINDER: ListPublishedByTag
// PARAMS: status map[string]any, id map[string]any
// RETURNS: []domain.Post
func (r *PostRepository) ListPublishedByTag(ctx context.Context, status map[string]any, id map[string]any) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE status = $1 AND id IN $2
		ORDER BY published_at DESC
	`, status, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal sql.NullString
		var authoridVal sql.NullString
		var titleVal sql.NullString
		var slugVal sql.NullString
		var contentVal sql.NullString
		var excerptVal sql.NullString
		var statusVal sql.NullString
		var publishedatVal sql.NullString
		var viewcountVal sql.NullString
		var createdatVal sql.NullString
		var updatedatVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if authoridVal.Valid {
			unmarshalJSON(authoridVal.String, &entity.AuthorID)
		}
		if titleVal.Valid {
			unmarshalJSON(titleVal.String, &entity.Title)
		}
		if slugVal.Valid {
			unmarshalJSON(slugVal.String, &entity.Slug)
		}
		if contentVal.Valid {
			unmarshalJSON(contentVal.String, &entity.Content)
		}
		if excerptVal.Valid {
			unmarshalJSON(excerptVal.String, &entity.Excerpt)
		}
		if statusVal.Valid {
			unmarshalJSON(statusVal.String, &entity.Status)
		}
		if publishedatVal.Valid {
			unmarshalJSON(publishedatVal.String, &entity.PublishedAt)
		}
		if viewcountVal.Valid {
			unmarshalJSON(viewcountVal.String, &entity.ViewCount)
		}
		if createdatVal.Valid {
			unmarshalJSON(createdatVal.String, &entity.CreatedAt)
		}
		if updatedatVal.Valid {
			unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: CountPublishedByTag
// PARAMS: status map[string]any, id map[string]any
// RETURNS: int64
func (r *PostRepository) CountPublishedByTag(ctx context.Context, status map[string]any, id map[string]any) (int64, error) {
	if r.DB == nil {
		return 0, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	row := exec.QueryRow(ctx, `
		SELECT COUNT(*)
		FROM posts
		WHERE status = $1 AND id IN $2
		LIMIT 1
	`, status, id)
	var v int64
	if err := row.Scan(&v); err != nil {
		if err.Error() == "no rows in result set" {
			return 0, nil
		}
		return 0, err
	}
	return v, nil
}

// FINDER: ListByAuthor
// PARAMS: authorID string
// RETURNS: []domain.Post
func (r *PostRepository) ListByAuthor(ctx context.Context, authorID string) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE author_id = $1
		ORDER BY created_at DESC
	`, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal sql.NullString
		var authoridVal sql.NullString
		var titleVal sql.NullString
		var slugVal sql.NullString
		var contentVal sql.NullString
		var excerptVal sql.NullString
		var statusVal sql.NullString
		var publishedatVal sql.NullString
		var viewcountVal sql.NullString
		var createdatVal sql.NullString
		var updatedatVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if authoridVal.Valid {
			unmarshalJSON(authoridVal.String, &entity.AuthorID)
		}
		if titleVal.Valid {
			unmarshalJSON(titleVal.String, &entity.Title)
		}
		if slugVal.Valid {
			unmarshalJSON(slugVal.String, &entity.Slug)
		}
		if contentVal.Valid {
			unmarshalJSON(contentVal.String, &entity.Content)
		}
		if excerptVal.Valid {
			unmarshalJSON(excerptVal.String, &entity.Excerpt)
		}
		if statusVal.Valid {
			unmarshalJSON(statusVal.String, &entity.Status)
		}
		if publishedatVal.Valid {
			unmarshalJSON(publishedatVal.String, &entity.PublishedAt)
		}
		if viewcountVal.Valid {
			unmarshalJSON(viewcountVal.String, &entity.ViewCount)
		}
		if createdatVal.Valid {
			unmarshalJSON(createdatVal.String, &entity.CreatedAt)
		}
		if updatedatVal.Valid {
			unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// FINDER: ListByAuthorAndStatus
// PARAMS: authorID string, status map[string]any
// RETURNS: []domain.Post
func (r *PostRepository) ListByAuthorAndStatus(ctx context.Context, authorID string, status map[string]any) ([]domain.Post, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("db not configured")
	}
	exec := getExecutor(ctx, r.DB)
	rows, err := exec.Query(ctx, `
		SELECT id, authorid, title, slug, content, excerpt, status, publishedat, viewcount, createdat, updatedat
		FROM posts
		WHERE author_id = $1 AND status = $2
		ORDER BY created_at DESC
	`, authorID, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []domain.Post
	for rows.Next() {
		var entity domain.Post
		var idVal sql.NullString
		var authoridVal sql.NullString
		var titleVal sql.NullString
		var slugVal sql.NullString
		var contentVal sql.NullString
		var excerptVal sql.NullString
		var statusVal sql.NullString
		var publishedatVal sql.NullString
		var viewcountVal sql.NullString
		var createdatVal sql.NullString
		var updatedatVal sql.NullString
		if err := rows.Scan(
			&idVal,
			&authoridVal,
			&titleVal,
			&slugVal,
			&contentVal,
			&excerptVal,
			&statusVal,
			&publishedatVal,
			&viewcountVal,
			&createdatVal,
			&updatedatVal,
		); err != nil {
			return nil, err
		}
		if idVal.Valid {
			unmarshalJSON(idVal.String, &entity.ID)
		}
		if authoridVal.Valid {
			unmarshalJSON(authoridVal.String, &entity.AuthorID)
		}
		if titleVal.Valid {
			unmarshalJSON(titleVal.String, &entity.Title)
		}
		if slugVal.Valid {
			unmarshalJSON(slugVal.String, &entity.Slug)
		}
		if contentVal.Valid {
			unmarshalJSON(contentVal.String, &entity.Content)
		}
		if excerptVal.Valid {
			unmarshalJSON(excerptVal.String, &entity.Excerpt)
		}
		if statusVal.Valid {
			unmarshalJSON(statusVal.String, &entity.Status)
		}
		if publishedatVal.Valid {
			unmarshalJSON(publishedatVal.String, &entity.PublishedAt)
		}
		if viewcountVal.Valid {
			unmarshalJSON(viewcountVal.String, &entity.ViewCount)
		}
		if createdatVal.Valid {
			unmarshalJSON(createdatVal.String, &entity.CreatedAt)
		}
		if updatedatVal.Valid {
			unmarshalJSON(updatedatVal.String, &entity.UpdatedAt)
		}
		items = append(items, entity)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Ensure optional field scanners are referenced.
var _ = sql.NullString{}
