// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Template: mongo_repo.tmpl
// Repository: {{ ExportName .Name }}
// Entity: {{ ExportName .Entity }}
// Collection: {{ .Collection }}
// DO NOT EDIT - changes will be overwritten on next generation
// ============================================================================
// ============================================================================
// AUTO-GENERATED by ANG (Architectural Normalized Generator)
// Version: {{ ANGVersion }}
// InputHash: {{ InputHash }}
// CompilerHash: {{ CompilerHash }}
// DO NOT EDIT - changes will be overwritten on next generation
// GENERATED: true
// ============================================================================

package mongo

import (
	"context"
	"fmt"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"{{GoModule}}/internal/domain"
)

type {{ ExportName .Name }} struct {
	collection *mongo.Collection
}

func New{{ ExportName .Name }}(client *mongo.Client, dbName string) *{{ ExportName .Name }} {
	if client == nil {
		return &{{ ExportName .Name }}{collection: nil}
	}
	name := dbName
	if name == "" {
		name = "app"
	}
	col := client.Database(name).Collection("{{ .Collection }}")
	return &{{ ExportName .Name }}{collection: col}
}

func (r *{{ ExportName .Name }}) Save(ctx context.Context, entity *domain.{{ ExportName .Entity }}) error {
	if r.collection == nil {
		return fmt.Errorf("mongo not configured")
	}
	if entity == nil {
		return fmt.Errorf("entity is required")
	}
	if entity.ID == "" {
		return fmt.Errorf("entity id is required")
	}
	doc := {{ JSONName .Entity }}ToDoc(entity)
	_, err := r.collection.UpdateByID(
		ctx,
		entity.ID,
		bson.M{"$set": doc},
		options.Update().SetUpsert(true),
	)
	return err
}

func (r *{{ ExportName .Name }}) FindByID(ctx context.Context, id string) (*domain.{{ ExportName .Entity }}, error) {
	if r.collection == nil {
		return nil, fmt.Errorf("mongo not configured")
	}
	if id == "" {
		return nil, fmt.Errorf("id is required")
	}
	var doc {{ JSONName .Entity }}Doc
	if err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&doc); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return doc.ToDomain(), nil
}

func (r *{{ ExportName .Name }}) Delete(ctx context.Context, id string) error {
	if r.collection == nil {
		return fmt.Errorf("mongo not configured")
	}
	if id == "" {
		return fmt.Errorf("id is required")
	}
	_, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
	return err
}

{{- $hasListAll := false }}
{{- range .Finders }}{{ if eq .Name "ListAll" }}{{ $hasListAll = true }}{{ end }}{{ end }}
{{- if not $hasListAll }}
func (r *{{ ExportName .Name }}) ListAll(ctx context.Context, offset, limit int) ([]domain.{{ ExportName .Entity }}, error) {
	if r.collection == nil {
		return nil, fmt.Errorf("mongo not configured")
	}
	opts := options.Find().SetSkip(int64(offset)).SetLimit(int64(limit)).SetSort(bson.M{"_id": 1})
	cursor, err := r.collection.Find(ctx, bson.M{}, opts)
	if err != nil {
		return nil, fmt.Errorf("ListAll query: %w", err)
	}
	defer cursor.Close(ctx)
	var items []domain.{{ ExportName .Entity }}
	for cursor.Next(ctx) {
		var doc {{ JSONName .Entity }}Doc
		if err := cursor.Decode(&doc); err != nil {
			return nil, fmt.Errorf("ListAll decode: %w", err)
		}
		items = append(items, *doc.ToDomain())
	}
	return items, nil
}
{{- end }}

{{- range .Finders }}
func (r *{{ ExportName $.Name }}) {{ .Name }}(ctx context.Context{{ if .ParamsSig }}, {{ .ParamsSig }}{{ end }}) ({{ .ReturnType }}, error) {
	if r.collection == nil {
		return {{ .ReturnZero }}, fmt.Errorf("mongo not configured")
	}
	filter := bson.M{}
	{{- range $w := .Where }}
	{{- if eq $w.Op "=" }}
	filter["{{ MongoBsonName $w.Field }}"] = {{ $w.Param }}
	{{- else if eq $w.Op "<" }}
	filter["{{ MongoBsonName $w.Field }}"] = bson.M{"$lt": {{ $w.Param }}}
	{{- else if eq $w.Op ">" }}
	filter["{{ MongoBsonName $w.Field }}"] = bson.M{"$gt": {{ $w.Param }}}
	{{- else }}
	filter["{{ MongoBsonName $w.Field }}"] = {{ $w.Param }}
	{{- end }}
	{{- end }}

	{{- if eq .Action "delete" }}
	res, err := r.collection.DeleteMany(ctx, filter)
	if err != nil {
		return 0, err
	}
	return res.DeletedCount, nil
	{{- else if .IsCount }}
	count, err := r.collection.CountDocuments(ctx, filter)
	if err != nil {
		return 0, err
	}
	return count, nil
	{{- else if .ReturnSlice }}
	{{- if or .OrderByField .HasLimit }}
	opts := options.Find()
	{{- if .OrderByField }}
	opts.SetSort(bson.D{ {Key: "{{ .OrderByField }}", Value: {{ if .OrderByDesc }}-1{{ else }}1{{ end }}} })
	{{- end }}
	{{- if .HasLimit }}
	opts.SetLimit(int64({{ .Limit }}))
	{{- end }}
	cur, err := r.collection.Find(ctx, filter, opts)
	{{- else }}
	cur, err := r.collection.Find(ctx, filter)
	{{- end }}
	if err != nil {
		return {{ .ReturnZero }}, err
	}
	defer cur.Close(ctx)

	var items {{ .ReturnType }}
	for cur.Next(ctx) {
		var doc {{ JSONName $.Entity }}Doc
		if err := cur.Decode(&doc); err != nil {
			return {{ .ReturnZero }}, err
		}
		items = append(items, *doc.ToDomain())
	}
	if err := cur.Err(); err != nil {
		return {{ .ReturnZero }}, err
	}
	return items, nil
	{{- else }}
	{{- if .OrderByField }}
	opts := options.FindOne().SetSort(bson.D{ {Key: "{{ .OrderByField }}", Value: {{ if .OrderByDesc }}-1{{ else }}1{{ end }}} })
	var doc {{ JSONName $.Entity }}Doc
	if err := r.collection.FindOne(ctx, filter, opts).Decode(&doc); err != nil {
		if err == mongo.ErrNoDocuments {
			return {{ .ReturnZero }}, nil
		}
		return {{ .ReturnZero }}, err
	}
	return doc.ToDomain(), nil
	{{- else }}
	var doc {{ JSONName $.Entity }}Doc
	if err := r.collection.FindOne(ctx, filter).Decode(&doc); err != nil {
		if err == mongo.ErrNoDocuments {
			return {{ .ReturnZero }}, nil
		}
		return {{ .ReturnZero }}, err
	}
	return doc.ToDomain(), nil
	{{- end }}
	{{- end }}
}

{{- end }}

type {{ JSONName .Entity }}Doc struct {
{{- range .Fields }}
	{{ ExportName .Name }} {{ .Type }} `bson:"{{ if eq (ToLower .Name) "id" }}_id{{ else }}{{ JSONName .Name }}{{ end }}"`
{{- end }}
}

func {{ JSONName .Entity }}ToDoc(entity *domain.{{ ExportName .Entity }}) {{ JSONName .Entity }}Doc {
	return {{ JSONName .Entity }}Doc{
		{{- range .Fields }}
		{{ ExportName .Name }}: {{ MongoValueExpr . }},
		{{- end }}
	}
}

func (d {{ JSONName .Entity }}Doc) ToDomain() *domain.{{ ExportName .Entity }} {
	return &domain.{{ ExportName .Entity }}{
		{{- range .Fields }}
		{{ ExportName .Name }}: d.{{ ExportName .Name }},
		{{- end }}
	}
}
