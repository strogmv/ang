// Generated by ANG. Do not edit.
import { useQuery, useMutation, useQueryClient, useInfiniteQuery, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
import * as Types from '../types';
import * as QueryOptions from '../query-options';
import * as LegacyQueries from '../queries';
import * as api from '../endpoints';
import { wsClient, useWebsocketSubscription, useAutoInvalidation } from './websocket-hooks';
import { queryKeys } from '../query-keys';
import { useAuthStore } from '../auth-store';
// @ts-ignore
import { useEffect, useRef, useLayoutEffect } from 'react';

export { wsClient, useWebsocketSubscription, useAutoInvalidation };

{{- range .Endpoints }}
{{- if eq .Method "GET" }}
{{- $argList := PathArgNames .Path }}
export const use{{ .RPC }} = (params?: Types.{{ .RPC }}Request, options?: Omit<UseQueryOptions<Types.{{ .RPC }}Response, Error, Types.{{ .RPC }}Response, any[]>, 'queryKey' | 'queryFn'>) => {
  const hasRequiredParams = {{- if gt (len $argList) 0 -}} !!({{- range $i, $a := $argList -}}{{ if $i }} && {{ end }}(((params as any)?.{{ $a }} ?? (params as any)?.{{ JSONName $a }})){{- end -}}) {{- else -}} true {{- end }};
  {{- $optRes := QueryOptionsResource .RPC }}
  {{- $optKind := QueryOptionsKind .RPC }}
  {{- if and $optRes (eq $optKind "detail") }}
  const queryClient = useQueryClient();
  {{- end }}
  return useQuery({
    {{- if and $optRes (eq $optKind "detail") }}
    placeholderData: () => {
      const id = ((params as any)?.{{ QueryOptionsDetailParam .RPC }});
      if (!id) return undefined;
      const cachedLists = queryClient.getQueriesData<any>({
        queryKey: queryKeys.{{ $optRes }}.lists()
      });
      for (const [, listData] of cachedLists) {
        const found = listData?.data?.find((item: any) => item.id === id);
        if (found) return { data: found } as any;
      }
      return undefined;
    },
    {{- end }}
    {{- if $optRes }}
    {{- $optKind := QueryOptionsKind .RPC }}
    {{- if eq $optKind "list" }}
    ...QueryOptions.{{ $optRes }}Options.list(params),
    {{- else if eq $optKind "detail" }}
    ...QueryOptions.{{ $optRes }}Options.detail(((params as any)?.{{ QueryOptionsDetailParam .RPC }})),
    {{- else if eq $optKind "me" }}
    ...QueryOptions.{{ $optRes }}Options.me(),
    {{- else }}
    ...LegacyQueries.{{ LowerFirst .RPC }}QueryOptions(params),
    {{- end }}
    {{- else }}
    ...LegacyQueries.{{ LowerFirst .RPC }}QueryOptions(params),
    {{- end }}
    ...options,
    enabled: hasRequiredParams && (options?.enabled ?? true),
  } as any);
};

export const use{{ .RPC }}Suspense = (params?: Types.{{ .RPC }}Request, options?: Omit<UseQueryOptions<Types.{{ .RPC }}Response, Error, Types.{{ .RPC }}Response, any[]>, 'queryKey' | 'queryFn'>) => {
  const hasRequiredParams = {{- if gt (len $argList) 0 -}} !!({{- range $i, $a := $argList -}}{{ if $i }} && {{ end }}(((params as any)?.{{ $a }} ?? (params as any)?.{{ JSONName $a }})){{- end -}}) {{- else -}} true {{- end }};
  {{- $optRes := QueryOptionsResource .RPC }}
  return useQuery({
    {{- if $optRes }}
    {{- $optKind := QueryOptionsKind .RPC }}
    {{- if eq $optKind "list" }}
    ...QueryOptions.{{ $optRes }}Options.list(params),
    {{- else if eq $optKind "detail" }}
    ...QueryOptions.{{ $optRes }}Options.detail(((params as any)?.{{ QueryOptionsDetailParam .RPC }})),
    {{- else if eq $optKind "me" }}
    ...QueryOptions.{{ $optRes }}Options.me(),
    {{- else }}
    ...LegacyQueries.{{ LowerFirst .RPC }}QueryOptions(params),
    {{- end }}
    {{- else }}
    ...LegacyQueries.{{ LowerFirst .RPC }}QueryOptions(params),
    {{- end }}
    ...options,
    suspense: true,
    enabled: hasRequiredParams && (options?.enabled ?? true),
  } as any);
};

{{- if .Pagination }}
export const useInfinite{{ .RPC }} = (params?: Types.{{ .RPC }}Request, options?: any) => {
  const hasRequiredParams = {{- if gt (len $argList) 0 -}} !!({{- range $i, $a := $argList -}}{{ if $i }} && {{ end }}(((params as any)?.{{ $a }} ?? (params as any)?.{{ JSONName $a }})){{- end -}}) {{- else -}} true {{- end }};
  return useInfiniteQuery({
    ...LegacyQueries.{{ LowerFirst .RPC }}InfiniteQueryOptions(params),
    ...options,
    enabled: hasRequiredParams && (options?.enabled ?? true),
  } as any);
};

export const useInfinite{{ .RPC }}Suspense = (params?: Types.{{ .RPC }}Request, options?: any) => {
  const hasRequiredParams = {{- if gt (len $argList) 0 -}} !!({{- range $i, $a := $argList -}}{{ if $i }} && {{ end }}(((params as any)?.{{ $a }} ?? (params as any)?.{{ JSONName $a }})){{- end -}}) {{- else -}} true {{- end }};
  return useInfiniteQuery({
    ...LegacyQueries.{{ LowerFirst .RPC }}InfiniteQueryOptions(params),
    ...options,
    suspense: true,
    enabled: hasRequiredParams && (options?.enabled ?? true),
  } as any);
};
{{- end }}
{{- else if eq .Method "WS" }}
{{- $params := PathParams .Path }}
{{- $args := PathArgs .Path }}
export const use{{ .RPC }}Raw = ({{- if ne $params "" }}{{ $params }}, {{ end }}onMessage: (data: any) => void) => {
  // Ref-pattern: stable subscription, always calls the latest callback.
  const onMessageRef = useRef(onMessage);
  useLayoutEffect(() => { onMessageRef.current = onMessage; });

  useEffect(() => {
    {{- if ne $params "" }}
    const wsUrl = ((import.meta as any).env?.VITE_API_URL || 'http://localhost:8080').replace(/^http/, 'ws') + `{{ PathTemplate .Path }}`;
    const client = new WebSocketClient(wsUrl);
    const unsubscribe = client.subscribe((data: any) => onMessageRef.current(data));
    return () => {
      unsubscribe();
      client.close();
    };
    {{- else }}
    const unsubscribe = wsClient.subscribe((data: any) => onMessageRef.current(data));
    return () => unsubscribe();
    {{- end }}
  }, [{{ $args }}]);
};
{{- else }}
{{- $relatedRPC := GetRelatedReadRPC . }}
{{- if ne $relatedRPC "" }}
export const use{{ .RPC }} = (options?: UseMutationOptions<Types.{{ .RPC }}Response, Error, Types.{{ .RPC }}Request, any>) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (variables: Types.{{ .RPC }}Request) => {
      return api.{{ LowerFirst .RPC }}(variables);
    },
    // Optimistic Update for {{ $relatedRPC }}
    onMutate: async (variables: Types.{{ .RPC }}Request) => {
        {{- /* Check if it's a detail update or list update */ -}}
        {{- $isList := or (HasPrefix $relatedRPC "List") (HasPrefix $relatedRPC "AdminList") }}
        const id = (variables as any).id || (variables as any).{{ GetEntityIDParam .RPC }};
        
        {{- if $isList }}
        // List Update
        {{- $resourceKey := QueryResourceKeyForRPC $relatedRPC }}
        const queryKey = {{- if $resourceKey }}queryKeys.{{ $resourceKey }}.list(){{- else }}queryKeys.{{ .ServiceName }}.{{ $relatedRPC }}(){{- end }}; // Invalidate all lists of this type
        await queryClient.cancelQueries({ queryKey });
        const previousData = queryClient.getQueryData(queryKey);

        {{ if eq .Method "POST" }}
        // Add to list
        queryClient.setQueryData(queryKey, (old: any) => {
            if (!old?.data) return old;
            return { ...old, data: [variables, ...old.data] };
        });
        {{ else if eq .Method "DELETE" }}
        // Remove from list
        queryClient.setQueryData(queryKey, (old: any) => {
            if (!old?.data) return old;
            return { ...old, data: old.data.filter((i: any) => i.id !== id) };
        });
        {{ end }}
        return { previousData, queryKey };

        {{- else }}
        // Detail Update
        if (!id) return; 
        const rpcParams = { id } as any; 
        {{- $resourceKey := QueryResourceKeyForRPC $relatedRPC }}
        const queryKey = {{- if $resourceKey }}queryKeys.{{ $resourceKey }}.detail(rpcParams){{- else }}queryKeys.{{ .ServiceName }}.{{ $relatedRPC }}(rpcParams){{- end }};

        await queryClient.cancelQueries({ queryKey });
        const previousData = queryClient.getQueryData(queryKey);
        queryClient.setQueryData(queryKey, (old: any) => {
            return old ? { ...old, ...variables } : variables;
        });
        return { previousData, queryKey };
        {{- end }}
    },
    onError: (_err: Error, _variables: Types.{{ .RPC }}Request, context: any) => {
        if (context?.previousData) {
            queryClient.setQueryData(context.queryKey, context.previousData);
        }
    },
    onSettled: (_data: any, _error: Error | null, _variables: Types.{{ .RPC }}Request, context: any) => {
        if (context?.queryKey) {
            queryClient.invalidateQueries({ queryKey: context.queryKey });
        }
        {{- $serviceName := .ServiceName }}
        {{- range .Invalidate }}
        {{- $resourceKey := QueryResourceKeyForRPC . }}
        {{- $kind := QueryResourceKindForRPC . }}
        {{- if and $resourceKey (eq $kind "list") }}
        queryClient.invalidateQueries({ queryKey: queryKeys.{{ $resourceKey }}.list() });
        {{- else }}
        queryClient.invalidateQueries({ queryKey: [...queryKeys.{{ $serviceName }}.all, '{{ . }}'] });
        {{- end }}
        {{- end }}
    },
    ...options,
  });
};
{{- else }}
export const use{{ .RPC }} = (options?: UseMutationOptions<Types.{{ .RPC }}Response, Error, Types.{{ .RPC }}Request, any>) => {
  {{- if .Invalidate }}
  const queryClient = useQueryClient();
  {{- end }}

  return useMutation({
    mutationFn: async (variables: Types.{{ .RPC }}Request) => {
      return api.{{ LowerFirst .RPC }}(variables);
    },
    {{- if IsAuthLoginRPC .RPC }}
    onSuccess: (data: Types.{{ .RPC }}Response) => {
      const store = useAuthStore.getState();
      store.setAuth((data as any).accessToken, store.user, (data as any).refreshToken ?? undefined);
    },
    {{- end }}
    {{- if .Invalidate }}
    onSettled: (_data: any, _error: Error | null, _variables: Types.{{ .RPC }}Request) => {
        {{- $serviceName := .ServiceName }}
        {{- range .Invalidate }}
        {{- $resourceKey := QueryResourceKeyForRPC . }}
        {{- $kind := QueryResourceKindForRPC . }}
        {{- if and $resourceKey (eq $kind "list") }}
        queryClient.invalidateQueries({ queryKey: queryKeys.{{ $resourceKey }}.list() });
        {{- else }}
        queryClient.invalidateQueries({ queryKey: [...queryKeys.{{ $serviceName }}.all, '{{ . }}'] });
        {{- end }}
        {{- end }}
    },
    {{- end }}
    ...options,
  });
};
{{- end }}
{{- end }}
{{- end }}
